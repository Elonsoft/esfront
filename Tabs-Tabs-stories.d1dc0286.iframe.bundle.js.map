{"version":3,"file":"Tabs-Tabs-stories.d1dc0286.iframe.bundle.js","mappings":";;;;;;;AAqHA","sources":["webpack://@esfront/react/./src/components/Tabs/Tabs.tsx"],"sourcesContent":["import {\n  Children,\n  cloneElement,\n  CSSProperties,\n  forwardRef,\n  isValidElement,\n  KeyboardEvent,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\n\nimport { TabsProps } from './Tabs.types';\n\nimport clsx from 'clsx';\nimport { getTabsUtilityClass, tabsClasses } from './Tabs.classes';\n\nimport { unstable_composeClasses as composeClasses } from '@mui/base';\n\nimport { keyframes, styled, useTheme, useThemeProps } from '@mui/material/styles';\nimport { debounce, ownerDocument, ownerWindow, useEventCallback } from '@mui/material/utils';\nimport useEnhancedEffect from '@mui/material/utils/useEnhancedEffect';\nimport { detectScrollType, getNormalizedScrollLeft } from '@mui/utils/scrollLeft';\n\nimport { animate } from './animate';\nimport { TabScrollButton, tabScrollButtonClasses } from './TabScrollButton';\n\nimport { Divider } from '../Divider';\n\nconst expandFromCenterKeyframe = keyframes`\n  0% {\n    transform: scaleX(0);\n  }\n  100% {\n    transform: scaleX(1);\n  }\n`;\n\ntype Overflow = 'visible' | 'hidden' | 'clip' | 'scroll' | 'auto';\n\ntype TabsOwnerState = {\n  centered: TabsProps['centered'];\n  classes?: TabsProps['classes'];\n  fixed: boolean;\n  indicatorColor: TabsProps['indicatorColor'];\n  hideScrollbar: boolean;\n  scrollableX: boolean;\n  scrollButtonsHideMobile: boolean;\n  overflow: Overflow | null;\n  TabIndicatorPosition?: TabsProps['TabIndicatorPosition'];\n  TabIndicatorSlidingAnimation?: TabsProps['TabIndicatorSlidingAnimation'];\n  visibleScrollbar: TabsProps['visibleScrollbar'];\n};\n\nconst ScrollbarSize = ({\n  onChange,\n  style,\n  ...props\n}: {\n  onChange: (height: number) => void;\n  style?: CSSProperties;\n  [key: string]: any;\n}) => {\n  const scrollbarHeight = useRef<number>(0);\n  const nodeRef = useRef<HTMLDivElement>(null);\n\n  const setMeasurements = () => {\n    if (nodeRef.current) {\n      scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;\n    }\n  };\n\n  useEnhancedEffect(() => {\n    if (nodeRef.current && scrollbarHeight.current) {\n      const handleResize = debounce(() => {\n        const prevHeight = scrollbarHeight.current;\n        setMeasurements();\n\n        if (prevHeight !== scrollbarHeight.current) {\n          onChange(scrollbarHeight.current);\n        }\n      });\n\n      const containerWindow = ownerWindow(nodeRef.current);\n      containerWindow.addEventListener('resize', handleResize);\n\n      return () => {\n        handleResize.clear();\n        containerWindow.removeEventListener('resize', handleResize);\n      };\n    }\n  }, [onChange]);\n\n  useEffect(() => {\n    setMeasurements();\n    onChange(scrollbarHeight.current);\n  }, [onChange]);\n\n  return (\n    <div\n      ref={nodeRef}\n      style={{\n        width: 99,\n        height: 99,\n        position: 'absolute',\n        top: -9999,\n        overflow: 'scroll',\n        ...style,\n      }}\n      {...props}\n    />\n  );\n};\n\nconst nextItem = (list: HTMLDivElement, item: HTMLElement) => {\n  if (list === item) {\n    return list.firstChild as HTMLElement;\n  }\n\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling as HTMLElement;\n  }\n\n  return list.firstChild as HTMLElement;\n};\n\nconst previousItem = (list: HTMLDivElement, item: HTMLElement) => {\n  if (list === item) {\n    return list.lastChild as HTMLElement;\n  }\n\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling as HTMLElement;\n  }\n\n  return list.lastChild as HTMLElement;\n};\n\nconst moveFocus = (\n  list: HTMLDivElement,\n  currentFocus: HTMLElement | null,\n  traversalFunction: (list: HTMLDivElement, item: HTMLElement) => HTMLElement | null\n) => {\n  let wrappedOnce = false;\n  let nextFocus = currentFocus && traversalFunction(list, currentFocus);\n\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return;\n      }\n\n      wrappedOnce = true;\n    }\n\n    const nextFocusDisabled = nextFocus.getAttribute('aria-disabled') === 'true';\n\n    if (!nextFocus.hasAttribute('tabindex') || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus);\n    } else {\n      nextFocus.focus();\n      return;\n    }\n  }\n};\n\nconst useUtilityClasses = (ownerState: TabsOwnerState) => {\n  const { fixed, hideScrollbar, scrollableX, centered, scrollButtonsHideMobile, classes } = ownerState;\n\n  const slots = {\n    root: ['root'],\n    scroller: ['scroller', fixed && 'fixed', hideScrollbar && 'hideScrollbar', scrollableX && 'scrollableX'],\n    flexContainer: ['flexContainer', centered && 'centered'],\n    indicator: ['indicator'],\n    scrollButtons: ['scrollButtons', scrollButtonsHideMobile && 'scrollButtonsHideMobile'],\n    scrollableX: [scrollableX && 'scrollableX'],\n    hideScrollbar: [hideScrollbar && 'hideScrollbar'],\n    tabsDivider: ['tabsDivider'],\n  };\n\n  return composeClasses(slots, getTabsUtilityClass, classes);\n};\n\nconst TabsRoot = styled('div', {\n  name: 'ESTabs',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const { ownerState } = props;\n\n    return [\n      { [`& .${tabsClasses.scrollButtons}`]: styles.scrollButtons },\n      {\n        [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles.scrollButtonsHideMobile,\n      },\n      styles.root,\n    ];\n  },\n})<{ ownerState: TabsOwnerState }>(({ theme }) => ({\n  position: 'relative',\n  overflow: 'hidden',\n  minHeight: 48,\n  // Add iOS momentum scrolling for iOS < 13.0\n  WebkitOverflowScrolling: 'touch',\n  display: 'flex',\n\n  variants: [\n    {\n      props: {\n        scrollButtonsHideMobile: true,\n      },\n      style: {\n        [`& .${tabsClasses.scrollButtons}`]: {\n          [theme.breakpoints.down('tabletXS')]: {\n            display: 'none',\n          },\n        },\n      },\n    },\n  ],\n}));\n\nconst TabsScroller = styled('div', {\n  name: 'ESTabs',\n  slot: 'Scroller',\n  overridesResolver: (props, styles) => {\n    const { ownerState } = props;\n    return [\n      styles.scroller,\n      ownerState.fixed && styles.fixed,\n      ownerState.hideScrollbar && styles.hideScrollbar,\n      ownerState.scrollableX && styles.scrollableX,\n      ownerState.scrollableY && styles.scrollableY,\n    ];\n  },\n})<{ ownerState: TabsOwnerState }>(() => ({\n  position: 'relative',\n  display: 'inline-block',\n  flex: '1 1 auto',\n  whiteSpace: 'nowrap',\n\n  variants: [\n    {\n      props: { overflow: 'visible' },\n      style: { overflow: 'visible' },\n    },\n    {\n      props: { overflow: 'hidden' },\n      style: { overflow: 'hidden' },\n    },\n    {\n      props: { overflow: 'clip' },\n      style: { overflow: 'clip' },\n    },\n    {\n      props: { overflow: 'scroll' },\n      style: { overflow: 'scroll' },\n    },\n    {\n      props: { overflow: 'auto' },\n      style: { overflow: 'auto' },\n    },\n    {\n      props: {\n        visibleScrollbar: true,\n      },\n      style: {\n        marginBottom: 'var(--ESTabs-scrollbarWidth)',\n      },\n    },\n    {\n      props: {\n        fixed: true,\n      },\n      style: {\n        overflowX: 'hidden',\n        width: '100%',\n      },\n    },\n    {\n      props: {\n        hideScrollbar: true,\n      },\n      style: {\n        scrollbarWidth: 'none',\n        '&::-webkit-scrollbar': {\n          display: 'none',\n        },\n      },\n    },\n    {\n      props: {\n        scrollableX: true,\n      },\n      style: {\n        overflowX: 'auto',\n        overflowY: 'hidden',\n      },\n    },\n  ],\n}));\n\nconst FlexContainer = styled('div', {\n  name: 'ESTabs',\n  slot: 'FlexContainer',\n  overridesResolver: (props, styles) => {\n    const { ownerState } = props;\n    return [styles.flexContainer, ownerState.centered && styles.centered];\n  },\n})<{ ownerState: TabsOwnerState }>(() => ({\n  display: 'flex',\n  padding: '0 16px',\n\n  variants: [\n    {\n      props: {\n        centered: true,\n      },\n      style: {\n        justifyContent: 'center',\n      },\n    },\n  ],\n}));\n\nconst TabsIndicator = styled('span', {\n  name: 'ESTabs',\n  slot: 'Indicator',\n  overridesResolver: (props, styles) => styles.indicator,\n})<{ ownerState: TabsOwnerState }>(({ theme }) => ({\n  position: 'absolute',\n  height: 2,\n\n  variants: [\n    {\n      props: {\n        TabIndicatorSlidingAnimation: 'expand',\n      },\n      style: {\n        animationName: expandFromCenterKeyframe,\n        animationDuration: '200ms',\n      },\n    },\n    {\n      props: {\n        TabIndicatorSlidingAnimation: 'slide',\n      },\n      style: {\n        transition: theme.transitions.create(['left', 'right', 'width'], {\n          duration: '200ms',\n        }),\n      },\n    },\n    {\n      props: {\n        TabIndicatorPosition: 'bottom',\n      },\n      style: {\n        bottom: 0,\n      },\n    },\n    {\n      props: {\n        TabIndicatorPosition: 'top',\n      },\n      style: {\n        top: 0,\n      },\n    },\n    {\n      props: {\n        indicatorColor: 'primary',\n      },\n      style: {\n        backgroundColor: theme.vars.palette.primary[300],\n      },\n    },\n    {\n      props: {\n        indicatorColor: 'secondary',\n      },\n      style: {\n        backgroundColor: theme.vars.palette.secondary[300],\n      },\n    },\n  ],\n}));\n\nconst TabsScrollbarSize = styled(ScrollbarSize)({\n  overflowX: 'auto',\n  overflowY: 'hidden',\n  // Hide dimensionless scrollbar on macOS\n  // Firefox\n  scrollbarWidth: 'none',\n  '&::-webkit-scrollbar': {\n    // Safari + Chrome\n    display: 'none',\n  },\n});\n\nconst TabsDivider = styled(Divider, {\n  name: 'ESTabs',\n  slot: 'TabsDivider',\n  overridesResolver: (props, styles) => [styles.tabsDivider],\n})<{ ownerState: TabsOwnerState }>(({ theme }) => ({\n  position: 'absolute',\n  zIndex: 3,\n  width: '100%',\n  borderColor: theme.vars.palette.monoA.A100,\n\n  variants: [\n    {\n      props: {\n        TabIndicatorPosition: 'bottom',\n      },\n      style: {\n        bottom: 0,\n      },\n    },\n\n    {\n      props: {\n        TabIndicatorPosition: 'top',\n      },\n      style: {\n        top: 0,\n      },\n    },\n  ],\n}));\n\nconst defaultIndicatorStyle: { [key: string]: number } = {};\nlet warnedOnceTabPresent = false;\n\nexport const Tabs = forwardRef<HTMLDivElement, TabsProps>(function Tabs(inProps: TabsProps, ref) {\n  const {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    action,\n    centered = false,\n    children: childrenProp,\n    className,\n    component = 'div',\n    allowScrollButtonsMobile = false,\n    indicatorColor = 'primary',\n    onChange,\n    ScrollButtonComponent = TabScrollButton,\n    scrollButtons = 'auto',\n    selectionFollowsFocus,\n    slots = {},\n    TabIndicatorAlignment = 'center',\n    TabIndicatorSlidingAnimation = 'slide',\n    TabIndicatorPosition = 'bottom',\n    TabIndicatorWidth = '100%',\n    TabIndicatorProps = {},\n    TabScrollButtonProps = {},\n    value,\n    variant = 'standard',\n    visibleScrollbar = false,\n    ...props\n  } = useThemeProps({ props: inProps, name: 'ESTabs' });\n  const theme = useTheme();\n  const isRtl = theme.direction === 'rtl';\n\n  const scrollable = variant === 'scrollable';\n\n  const scrollStart = 'scrollLeft';\n  const start = 'left';\n  const end = 'right';\n  const clientSize = 'clientWidth';\n  const size = 'width';\n  const startIndicator: 'right' | 'left' = isRtl ? 'right' : 'left';\n\n  if (centered && scrollable) {\n    console.error(\n      'You can not use the `centered={true}` and `variant=\"scrollable\"` properties ' +\n        'at the same time on a `Tabs` component.'\n    );\n  }\n\n  const [mounted, setMounted] = useState(false);\n  const [indicatorStyle, setIndicatorStyle] = useState(defaultIndicatorStyle);\n  const [displayStartScroll, setDisplayStartScroll] = useState(false);\n  const [displayEndScroll, setDisplayEndScroll] = useState(false);\n  const [updateScrollObserver, setUpdateScrollObserver] = useState(false);\n\n  const [scrollerStyle, setScrollerStyle] = useState<{ overflow: Overflow | null; scrollbarWidth: number }>({\n    overflow: 'hidden',\n    scrollbarWidth: 0,\n  });\n\n  const valueToIndex = new Map();\n  const tabsRef = useRef<HTMLDivElement>(null);\n  const tabListRef = useRef<HTMLDivElement>(null);\n\n  const ownerState = {\n    ...props,\n    component,\n    allowScrollButtonsMobile,\n    indicatorColor,\n    scrollButtons,\n    overflow: scrollerStyle.overflow,\n    variant,\n    visibleScrollbar,\n    fixed: !scrollable,\n    hideScrollbar: scrollable && !visibleScrollbar,\n    scrollableX: !!scrollable,\n    centered: centered && !scrollable,\n    scrollButtonsHideMobile: !allowScrollButtonsMobile,\n    TabIndicatorPosition,\n    TabIndicatorSlidingAnimation,\n  };\n\n  const classes = useUtilityClasses(ownerState);\n\n  const getTabsMeta = () => {\n    const tabsNode = tabsRef.current;\n    let tabsMeta;\n\n    if (tabsNode) {\n      const rect = tabsNode.getBoundingClientRect();\n\n      // create a new object with ClientRect class props + scrollLeft\n      tabsMeta = {\n        clientWidth: tabsNode.clientWidth,\n        scrollLeft: tabsNode.scrollLeft,\n        scrollTop: tabsNode.scrollTop,\n        scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, isRtl ? 'rtl' : 'ltr'),\n        scrollWidth: tabsNode.scrollWidth,\n        top: rect.top,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right,\n      };\n    }\n\n    let tabMeta;\n\n    if (tabListRef.current && tabsNode && value !== false) {\n      const children = tabListRef.current.children;\n\n      if (children.length > 0) {\n        const tab = children[valueToIndex.get(value)];\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (!tab) {\n            console.error(\n              [\n                `The \\`value\\` provided to the Tabs component is invalid.`,\n                `None of the Tabs' children match with \"${value}\".`,\n                valueToIndex.keys\n                  ? `You can provide one of the following values: ${Array.from(valueToIndex.keys()).join(', ')}.`\n                  : null,\n              ].join('\\n')\n            );\n          }\n        }\n\n        tabMeta = tab ? tab.getBoundingClientRect() : null;\n\n        if (\n          tabsMeta &&\n          !warnedOnceTabPresent &&\n          tabMeta &&\n          tabMeta.width === 0 &&\n          tabMeta.height === 0 &&\n          // if the whole Tabs component is hidden, don't warn\n          tabsMeta.clientWidth !== 0\n        ) {\n          tabsMeta = null;\n\n          console.error(\n            [\n              'The `value` provided to the Tabs component is invalid.',\n              `The Tab with this \\`value\\` (\"${value}\") is not part of the document layout.`,\n              \"Make sure the tab item is present in the document or that it's not `display: none`.\",\n            ].join('\\n')\n          );\n\n          warnedOnceTabPresent = true;\n        }\n      }\n    }\n\n    return { tabsMeta, tabMeta };\n  };\n\n  const updateIndicatorState = useEventCallback(() => {\n    const { tabsMeta, tabMeta } = getTabsMeta();\n    let startValue = 0;\n    let modifiedIndicatorWidth = 0;\n\n    if (tabMeta && tabsMeta) {\n      const correction = isRtl\n        ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth\n        : tabsMeta.scrollLeft;\n\n      startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);\n    }\n\n    if (tabMeta && indicatorStyle[size] && TabIndicatorAlignment) {\n      const sizeDiff = tabMeta[size] - indicatorStyle[size];\n\n      switch (TabIndicatorAlignment) {\n        case 'center':\n          startValue += sizeDiff / 2;\n          break;\n        case 'right':\n          startValue += sizeDiff;\n      }\n    }\n\n    if (TabIndicatorWidth) {\n      const isWidthInPx = TabIndicatorWidth.includes('px');\n      const isWidthInPercentage = TabIndicatorWidth.includes('%');\n      const indicatorWidthInPx = +TabIndicatorWidth.split('px')[0];\n      const indicatorWidthOfTabWidth = (+TabIndicatorWidth.split('%')[0] / 100) * (tabMeta ? tabMeta[size] : 0);\n\n      modifiedIndicatorWidth = isWidthInPx\n        ? indicatorWidthInPx\n        : isWidthInPercentage\n          ? indicatorWidthOfTabWidth\n          : +TabIndicatorWidth;\n    }\n\n    const newIndicatorStyle = {\n      [startIndicator]: startValue,\n      // May be wrong until the font is loaded.\n      [size]: tabMeta ? (TabIndicatorWidth ? modifiedIndicatorWidth : tabMeta[size]) : 0,\n    };\n\n    // IE11 support, replace with Number.isNaN\n    if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {\n      setIndicatorStyle(newIndicatorStyle);\n    } else {\n      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);\n      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);\n\n      if (dStart >= 1 || dSize >= 1) {\n        setIndicatorStyle(newIndicatorStyle);\n      }\n    }\n  });\n\n  const scroll = (scrollValue: number, { animation = true }: { animation?: unknown | boolean } = {}) => {\n    if (animation && tabsRef.current) {\n      animate(scrollStart, tabsRef.current, scrollValue, {\n        duration: theme.transitions.duration.standard,\n      });\n    } else if (tabsRef.current) {\n      tabsRef.current[scrollStart] = scrollValue;\n    }\n  };\n\n  const moveTabsScroll = (delta: number) => {\n    if (tabsRef.current) {\n      let scrollValue = tabsRef.current[scrollStart];\n\n      scrollValue += delta * (isRtl ? -1 : 1);\n      // Fix for Edge\n      scrollValue *= isRtl && detectScrollType() === 'reverse' ? -1 : 1;\n\n      scroll(scrollValue);\n    }\n  };\n\n  const getScrollSize = () => {\n    if (tabsRef.current && tabListRef.current) {\n      const containerSize = tabsRef.current[clientSize];\n      let totalSize = 0;\n      const children = Array.from(tabListRef.current.children);\n\n      for (let i = 0; i < children.length; i += 1) {\n        const tab = children[i];\n\n        if (totalSize + tab[clientSize] > containerSize) {\n          // If the first item is longer than the container size, then only scroll\n          // by the container size.\n          if (i === 0) {\n            totalSize = containerSize;\n          }\n\n          break;\n        }\n\n        totalSize += tab[clientSize];\n      }\n\n      return totalSize;\n    }\n\n    return 0;\n  };\n\n  const handleStartScrollClick = () => {\n    moveTabsScroll(-1 * getScrollSize());\n  };\n\n  const handleEndScrollClick = () => {\n    moveTabsScroll(getScrollSize());\n  };\n\n  const handleScrollbarSizeChange = useCallback((scrollbarWidth: number) => {\n    setScrollerStyle({\n      overflow: null,\n      scrollbarWidth,\n    });\n  }, []);\n\n  const getConditionalElements = () => {\n    const conditionalElements: {\n      scrollbarSizeListener: JSX.Element | null;\n      scrollButtonStart: JSX.Element | null;\n      scrollButtonEnd: JSX.Element | null;\n    } = {\n      scrollbarSizeListener: null,\n      scrollButtonStart: null,\n      scrollButtonEnd: null,\n    };\n\n    conditionalElements.scrollbarSizeListener = scrollable ? (\n      <TabsScrollbarSize\n        className={clsx(classes.scrollableX, classes.hideScrollbar)}\n        onChange={handleScrollbarSizeChange}\n      />\n    ) : null;\n\n    const scrollButtonsActive = displayStartScroll || displayEndScroll;\n    const showScrollButtons =\n      scrollable && ((scrollButtons === 'auto' && scrollButtonsActive) || scrollButtons === true);\n\n    const tabListHeight = tabListRef.current?.clientHeight;\n\n    conditionalElements.scrollButtonStart = showScrollButtons ? (\n      <ScrollButtonComponent\n        direction={isRtl ? 'right' : 'left'}\n        disabled={!displayStartScroll}\n        slots={{ StartScrollButtonIcon: slots.StartScrollButtonIcon }}\n        tabListHeight={tabListHeight}\n        onClick={handleStartScrollClick}\n        {...TabScrollButtonProps}\n        className={clsx(classes.scrollButtons, TabScrollButtonProps.className)}\n      />\n    ) : null;\n\n    conditionalElements.scrollButtonEnd = showScrollButtons ? (\n      <ScrollButtonComponent\n        direction={isRtl ? 'left' : 'right'}\n        disabled={!displayEndScroll}\n        slots={{ EndScrollButtonIcon: slots.EndScrollButtonIcon }}\n        tabListHeight={tabListHeight}\n        onClick={handleEndScrollClick}\n        {...TabScrollButtonProps}\n        className={clsx(classes.scrollButtons, TabScrollButtonProps.className)}\n      />\n    ) : null;\n\n    return conditionalElements;\n  };\n\n  const scrollSelectedIntoView = useEventCallback((animation) => {\n    const { tabsMeta, tabMeta } = getTabsMeta();\n    const tabScrollButtonOffset = document\n      .querySelector(`.${tabScrollButtonClasses.root}`)\n      ?.getBoundingClientRect().width;\n\n    if (!tabMeta || !tabsMeta) {\n      return;\n    }\n\n    if (tabMeta[start] < tabsMeta[start]) {\n      // left side of button is out of view\n      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start] - tabsMeta[start]);\n      scroll(nextScrollStart - (tabScrollButtonOffset ? tabScrollButtonOffset : 0), { animation });\n    } else if (tabMeta[end] > tabsMeta[end]) {\n      // right side of button is out of view\n      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end] - tabsMeta[end]);\n      scroll(nextScrollStart + (tabScrollButtonOffset ? tabScrollButtonOffset : 0), { animation });\n    }\n  });\n\n  const updateScrollButtonState = useEventCallback(() => {\n    if (scrollable && scrollButtons !== false) {\n      setUpdateScrollObserver(!updateScrollObserver);\n    }\n  });\n\n  useEffect(() => {\n    const handleResize = debounce(() => {\n      // If the Tabs component is replaced by Suspense with a fallback, the last\n      // ResizeObserver's handler that runs because of the change in the layout is trying to\n      // access a dom node that is no longer there (as the fallback component is being shown instead).\n      if (tabsRef.current) {\n        updateIndicatorState();\n      }\n    });\n\n    let resizeObserver: ResizeObserver;\n\n    const handleMutation = (records: MutationRecord[]) => {\n      records.forEach((record) => {\n        record.removedNodes.forEach((item) => {\n          if (item.nodeType === Node.ELEMENT_NODE) {\n            resizeObserver?.unobserve(item as HTMLElement);\n          }\n        });\n\n        record.addedNodes.forEach((item) => {\n          if (item.nodeType === Node.ELEMENT_NODE) {\n            resizeObserver?.observe(item as HTMLElement);\n          }\n        });\n      });\n\n      handleResize();\n      updateScrollButtonState();\n    };\n\n    if (tabsRef.current && tabListRef.current) {\n      const win = ownerWindow(tabsRef.current);\n      win.addEventListener('resize', handleResize);\n\n      let mutationObserver: MutationObserver;\n\n      if (typeof ResizeObserver !== 'undefined') {\n        resizeObserver = new ResizeObserver(handleResize);\n\n        Array.from(tabListRef.current.children).forEach((child) => {\n          resizeObserver.observe(child);\n        });\n      }\n\n      if (typeof MutationObserver !== 'undefined') {\n        mutationObserver = new MutationObserver(handleMutation);\n\n        mutationObserver.observe(tabListRef.current, {\n          childList: true,\n        });\n      }\n\n      return () => {\n        handleResize.clear();\n        win.removeEventListener('resize', handleResize);\n        mutationObserver?.disconnect();\n        resizeObserver?.disconnect();\n      };\n    }\n  }, [updateIndicatorState, updateScrollButtonState]);\n\n  /**\n   * Toggle visibility of start and end scroll buttons\n   * Using IntersectionObserver on first and last Tabs.\n   */\n  useEffect(() => {\n    if (tabListRef.current) {\n      const tabListChildren = Array.from(tabListRef.current.children);\n      const length = tabListChildren.length;\n\n      if (typeof IntersectionObserver !== 'undefined' && length > 0 && scrollable && scrollButtons !== false) {\n        const firstTab = tabListChildren[0];\n        const lastTab = tabListChildren[length - 1];\n        const observerOptions = {\n          root: tabsRef.current,\n          threshold: 0.99,\n        };\n\n        const handleScrollButtonStart = (entries: IntersectionObserverEntry[]) => {\n          setDisplayStartScroll(!entries[0].isIntersecting);\n        };\n\n        const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);\n        firstObserver.observe(firstTab);\n\n        const handleScrollButtonEnd = (entries: IntersectionObserverEntry[]) => {\n          setDisplayEndScroll(!entries[0].isIntersecting);\n        };\n\n        const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);\n        lastObserver.observe(lastTab);\n\n        return () => {\n          firstObserver.disconnect();\n          lastObserver.disconnect();\n        };\n      }\n\n      return undefined;\n    }\n  }, [scrollable, scrollButtons, updateScrollObserver, childrenProp]);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  useEffect(() => {\n    updateIndicatorState();\n  });\n\n  useEffect(() => {\n    // Don't animate on the first render.\n    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);\n  }, [scrollSelectedIntoView, indicatorStyle]);\n\n  useImperativeHandle(\n    action,\n    () => ({\n      updateIndicator: updateIndicatorState,\n      updateScrollButtons: updateScrollButtonState,\n    }),\n    [updateIndicatorState, updateScrollButtonState]\n  );\n\n  const indicator = (\n    <TabsIndicator\n      key={TabIndicatorSlidingAnimation === 'expand' ? indicatorStyle[startIndicator] : undefined}\n      {...TabIndicatorProps}\n      className={clsx(classes.indicator, TabIndicatorProps.className)}\n      ownerState={ownerState}\n      style={{\n        ...indicatorStyle,\n        ...TabIndicatorProps.style,\n      }}\n    />\n  );\n\n  let childIndex = 0;\n  const children = Children.map(childrenProp, (child) => {\n    if (!isValidElement(child)) {\n      return null;\n    }\n\n    const childValue = child.props.value === undefined ? childIndex : child.props.value;\n    valueToIndex.set(childValue, childIndex);\n    const selected = childValue === value;\n\n    childIndex += 1;\n    return cloneElement(child as ReactElement, {\n      fullWidth: variant === 'fullWidth',\n      indicator: selected && !mounted && indicator,\n      selected,\n      selectionFollowsFocus,\n      onChange,\n      rounded: props.rounded,\n      value: childValue,\n      ...(childIndex === 1 && value === false && !child.props.tabIndex ? { tabIndex: 0 } : {}),\n    });\n  });\n\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (tabListRef.current) {\n      const list = tabListRef.current;\n      const currentFocus = ownerDocument(list).activeElement as HTMLElement;\n      // Keyboard navigation assumes that [role=\"tab\"] are siblings\n      // though we might warn in the future about nested, interactive elements\n      // as a a11y violation\n      const role = currentFocus.getAttribute('role');\n\n      if (role !== 'tab') {\n        return;\n      }\n\n      let previousItemKey = 'ArrowLeft';\n      let nextItemKey = 'ArrowRight';\n\n      if (isRtl) {\n        // swap previousItemKey with nextItemKey\n        previousItemKey = 'ArrowRight';\n        nextItemKey = 'ArrowLeft';\n      }\n\n      switch (event.key) {\n        case previousItemKey:\n          event.preventDefault();\n          moveFocus(list, currentFocus, previousItem);\n          break;\n        case nextItemKey:\n          event.preventDefault();\n          moveFocus(list, currentFocus, nextItem);\n          break;\n        case 'Home':\n          event.preventDefault();\n          moveFocus(list, null, nextItem);\n          break;\n        case 'End':\n          event.preventDefault();\n          moveFocus(list, null, previousItem);\n          break;\n        default:\n          break;\n      }\n    }\n  };\n\n  const conditionalElements = getConditionalElements();\n\n  return (\n    <TabsRoot\n      ref={ref}\n      as={component}\n      className={clsx(classes.root, className)}\n      ownerState={ownerState}\n      {...props}\n      style={{ '--ESTabs-scrollbarWidth': `-${scrollerStyle.scrollbarWidth}px` } as React.CSSProperties}\n    >\n      {conditionalElements.scrollButtonStart}\n      {conditionalElements.scrollbarSizeListener}\n      <TabsScroller ref={tabsRef} className={classes.scroller} ownerState={ownerState}>\n        {/* The tablist isn't interactive but the tabs are */}\n        <FlexContainer\n          ref={tabListRef}\n          aria-label={ariaLabel}\n          aria-labelledby={ariaLabelledBy}\n          className={classes.flexContainer}\n          ownerState={ownerState}\n          role=\"tablist\"\n          onKeyDown={handleKeyDown}\n        >\n          {children}\n        </FlexContainer>\n        {mounted && indicator}\n      </TabsScroller>\n      <TabsDivider className={classes.tabsDivider} ownerState={ownerState} />\n      {conditionalElements.scrollButtonEnd}\n    </TabsRoot>\n  );\n});\n"],"names":[],"sourceRoot":""}