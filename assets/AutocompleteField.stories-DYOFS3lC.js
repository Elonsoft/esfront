import{j as r}from"./jsx-runtime-BoZ7yaty.js";import{r as n}from"./index-DIDRz_s2.js";import{c as z}from"./clsx.m-C7bORDfW.js";import{g as K,a as J,s as T,c as Q}from"./styled-QckRPC_l.js";import{u as X}from"./DefaultPropsProvider-BgzOhfjl.js";import{u as Fe}from"./useControlled-DdQm0pQX.js";import{u as Be}from"./useId-DHFVogFr.js";import{O as De,I as je,t as We}from"./TextField-B-8j0Rl0.js";import{u as ke}from"./useFormControl-Crkhef2u.js";import{u as Ge}from"./useForkRef-Cmn-Dh7x.js";import{u as ge}from"./useEnhancedEffect-BGNjlb7u.js";import{A as He}from"./AutocompleteMenu-DQzgjP1m.js";import{F as $e}from"./FormHelperText-BEN161lL.js";import{F as ze}from"./FormControl-DlxfVnjv.js";import{B as Y}from"./Box-wRm4ebgR.js";import"./_commonjsHelpers-gnU0ypJ3.js";import"./memoTheme-DzcScnLI.js";import"./useSlot-CFc0_OMk.js";import"./mergeSlotProps-fp1W1fei.js";import"./appendOwnerState-BTP2NS_9.js";import"./DefaultPropsProvider-DX0NN56D.js";import"./formControlState-Dq1zat_P.js";import"./createSimplePaletteValueFilter-bm0fmN_7.js";import"./isHostComponent-DVu5iVWx.js";import"./index-CckzPfJL.js";import"./extendSxProp-DvIFaZWy.js";import"./useTheme-Dg4q0o-B.js";import"./emotion-react.browser.esm-Cye-CgRM.js";import"./ownerWindow-HkKU3E4x.js";import"./ownerDocument-DW-IO8s5.js";import"./useEventCallback-B5h_k30D.js";import"./debounce-Be36O1Ab.js";import"./Menu-_nfAmUNL.js";import"./index-CycuZXML.js";import"./useSlotProps-CexWkmt_.js";import"./Popover-DEEcjM6r.js";import"./useTheme-ErypeN0Y.js";import"./Grow-Dt_8BulK.js";import"./getReactElementRef-BCGM00pR.js";import"./TransitionGroupContext-8frXp1f-.js";import"./index-BqLR6Ykc.js";import"./index-B9nU-LZm.js";import"./useTimeout-BgqVTnbA.js";import"./mergeSlotProps-CDvdv1-t.js";import"./Modal-B7qrzaAx.js";import"./getScrollbarSize-CaCM53D3.js";import"./createChainedFunction-BO_9K8Jh.js";import"./Portal-Cdjvc33M.js";import"./FocusTrap-vTo9pgoY.js";import"./Fade-DWBj0t68.js";import"./MenuList-hBx3FRLR.js";import"./useControlled-BX5XFdR0.js";import"./createSvgIcon-3eNI6DIc.js";import"./SvgIcon-B3E_vWSd.js";import"./IconMagnify2W400-Bwryy7kb.js";import"./SvgIcon-DcWEUr91.js";import"./SvgIcon.classes-CE9bwLeY.js";import"./IconCloseW350-D-WsKF4y.js";import"./useIntersectionObserver-Bn-bajRp.js";import"./useLatest-sVqXUmVb.js";import"./MenuItem-CTB1bkQ4.js";import"./useForkRef-DJnV46t9.js";import"./ButtonBase-BtCzZW19.js";import"./ClickAwayListener-fiuBl2rs.js";import"./InputAdornment-Djc9DkaM.js";import"./Typography-dCWir4IF.js";import"./Button-CL4pDWwx.js";import"./SpinnerRing-DHLeqoVH.js";import"./Spinner.utils-DeMV3qAC.js";import"./Divider-CH9ZVQ77.js";import"./TooltipEllipsis-D5NvwasF.js";import"./useResizeObserver-BNbozrrH.js";import"./Tooltip-BqXojrKv.js";import"./useEvent-B4f6aq-e.js";import"./Popper-5tNl5wyi.js";import"./Checkbox-88teVN7k.js";import"./Checkbox.classes-Di0bQe5l.js";import"./SwitchBase-B94b24U2.js";import"./isMuiElement-DbqDAyDR.js";const Ke=e=>{const t=n.useRef(e);return n.useEffect(()=>(t.current=e,()=>{t.current=void 0})),t.current};function Je(e){return J("ESAutocomplete",e)}const Qe=K("ESAutocomplete",["root","input","menu","displayValue","inputPlaceholder"]);function Xe(e){return J("ESAutocompleteMenuFooter",e)}K("ESAutocompleteMenuFooter",["root"]);const Ye=e=>{const{classes:t}=e;return Q({root:["root"]},Xe,t)},Ze=T("div",{name:"ESAutocompleteMenuFooter",slot:"Root",overridesResolver:(e,t)=>t.root})(({theme:e})=>({...e.typography.caption,color:e.vars.palette.monoA.A600,padding:"5px 16px 6px",borderTop:`1px solid ${e.vars.palette.monoA.A100}`})),ie=e=>{const{className:t,sx:o,children:f,...d}=X({props:e,name:"ESAutocompleteMenuFooter"}),c={...d},p=Ye(c);return r.jsx(Ze,{className:z(p.root,t),sx:o,children:f})};try{ie.displayName="AutocompleteMenuFooter",ie.__docgenInfo={description:"",displayName:"AutocompleteMenuFooter",props:{classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<AutocompleteMenuFooterClasses>"}},className:{defaultValue:null,description:"Class applied to the root element.",name:"className",required:!1,type:{name:"string"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}}}}}catch{}function et(e){return J("ESAutocompleteMenuHeader",e)}K("ESAutocompleteMenuHeader",["root"]);const tt=e=>{const{classes:t}=e;return Q({root:["root"]},et,t)},ot=T("div",{name:"ESAutocompleteMenuHeader",slot:"Root",overridesResolver:(e,t)=>t.root})(({theme:e})=>({...e.typography.caption,color:e.vars.palette.monoA.A600,padding:"6px 16px 5px",borderBottom:`1px solid ${e.vars.palette.monoA.A100}`})),ue=e=>{const{className:t,sx:o,children:f,...d}=X({props:e,name:"ESAutocompleteMenuHeader"}),c={...d},p=tt(c);return r.jsx(ot,{className:z(p.root,t),sx:o,children:f})};try{ue.displayName="AutocompleteMenuHeader",ue.__docgenInfo={description:"",displayName:"AutocompleteMenuHeader",props:{classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<AutocompleteMenuHeaderClasses>"}},className:{defaultValue:null,description:"Class applied to the root element.",name:"className",required:!1,type:{name:"string"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}}}}}catch{}const nt=e=>{const{classes:t}=e;return Q({root:["root"],input:["input"],menu:["menu"],displayValue:["displayValue"],inputPlaceholder:["inputPlaceholder"]},Je,t)},st=T(De,{name:"ESAutocomplete",slot:"Root",overridesResolver:(e,t)=>t.root})(()=>({cursor:"pointer",[`& .${Qe.input}`]:{width:"100%",outline:"none",whiteSpace:"nowrap",overflow:"hidden",display:"inline-flex",alignItems:"center"}})),rt=T(He,{name:"ESAutocomplete",slot:"Menu",overridesResolver:(e,t)=>t.menu})(()=>({pointerEvents:"auto",variants:[{props:{inlineSearch:!0},style:{pointerEvents:"none"}}]})),lt=T("div",{name:"ESAutocomplete",slot:"DisplayValue",overridesResolver:(e,t)=>t.displayValue})(()=>({minWidth:0,overflow:"hidden",textOverflow:"ellipsis"})),at=T("div",{name:"ESAutocomplete",slot:"InputPlaceholder",overridesResolver:(e,t)=>t.inputPlaceholder})(({theme:e})=>({color:e.vars.palette.monoA.A400,minWidth:0,overflow:"hidden",textOverflow:"ellipsis"})),pe=e=>{const{className:t,classes:o,sx:f,id:d,inputRef:c,label:p,name:y,placeholder:h,"aria-describedby":g,startAdornment:v,endAdornment:V,options:C,getOptionValue:U,getOptionLabel:q,getOptionDisabled:S,groupBy:M,MenuGroupProps:b,loading:ee,inlineSearch:l,header:te,footer:B,MenuProps:F,SearchProps:m,open:D,onOpen:R,onClose:x,onLoadMore:w,onBlur:j,...a}=X({props:e,name:"ESAutocomplete"}),s=ke();if(!s)throw new Error("No provider for FormControlContext.");const O=n.useRef(null),E=n.useRef(null),I=n.useRef(null),Re=Ge(I,c),oe=n.useRef(null),ne=n.useRef(!1),[se,re]=Fe(!1,D),[we,Ee]=n.useState(0),ce=Ke(s.focused),W=n.useMemo(()=>a.multiple?a.value:a.value?[a.value]:[],[a.multiple,a.value]),le=n.useMemo(()=>a.getDisplayValue?(a.multiple,a.getDisplayValue(a.value)):W.map(i=>q(i)).join(", "),[a.value,W]);ge(()=>{W.length?s.onFilled():s.onEmpty()},[W,s.onEmpty,s.onFilled,s.filled]),n.useEffect(()=>{j&&!s.focused&&ce&&(ne.current?ne.current=!1:j({target:{name:y}}))},[s.focused,ce]),ge(()=>{s.setAdornedStart(!!v)},[!!v]);const ae=n.useCallback(i=>{O.current&&(Ee(O.current.clientWidth),re(!0),R==null||R(),i||setTimeout(()=>{if(E.current){const u=E.current.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');u&&u.focus()}},0))},[]),Ie=n.useCallback((i,u)=>{var N;u==="escapeKeyDown"&&(ne.current=!0,requestAnimationFrame(()=>{I.current&&I.current.focus()})),!(l&&u==="clickAway"&&((N=O.current)!=null&&N.contains(i.target)))&&(re(!1),x==null||x())},[l]),Le=i=>{a.onChange&&a.onChange(i)},Ne=i=>{(l?["ArrowUp","ArrowDown","Enter"]:[" ","ArrowUp","ArrowDown","Enter"]).indexOf(i.key)!==-1&&(i.preventDefault(),ae()),["Escape","Tab"].indexOf(i.key)!==-1&&se&&(i.stopPropagation(),re(!1),x==null||x())},_e=i=>{var u,N;s.disabled||i.button!==0||((N=(u=oe.current)==null?void 0:u.setTrapFocusEnabled)==null||N.call(u,!1),requestAnimationFrame(()=>{var k,he;I.current&&I.current.focus(),(he=(k=oe.current)==null?void 0:k.setTrapFocusEnabled)==null||he.call(k,!0)}),ae(!!l))},me=s.filled||s.focused||!!v||!!se,fe={classes:o,inlineSearch:l},L=nt(fe);return r.jsxs(r.Fragment,{children:[r.jsx(st,{ref:O,autoComplete:l?"off":void 0,autoFocus:l?s.focused:!1,className:z(t,L.root),disabled:s.disabled,endAdornment:V,error:s.error,fullWidth:a.fullWidth,id:d,inputComponent:l&&s.focused?"input":"div",inputProps:{children:l&&s.focused?null:le?r.jsx(lt,{className:L.displayValue,children:le}):(me||!p)&&r.jsx(at,{className:L.inputPlaceholder,children:h}),className:L.input,role:l?"input":"button",tabIndex:s.disabled?-1:0,onBlur:i=>{var u;(u=s.onBlur)==null||u.call(s,i)},onFocus:i=>{var u;(u=s.onFocus)==null||u.call(s,i)},onKeyDown:Ne,"aria-describedby":g,...a.inputProps},inputRef:Re,label:p,name:y,notched:me,placeholder:l?h:void 0,required:s.required,startAdornment:v,sx:f,value:l&&s.focused?m==null?void 0:m.value:null,onChange:l&&s.focused?i=>{var u;(u=m==null?void 0:m.onChange)==null||u.call(m,i),ae(!0)}:void 0,onMouseDown:_e,children:l?null:le}),r.jsx(rt,{value:a.value,multiple:a.multiple,disableRestoreFocus:!0,MenuGroupProps:b,SearchProps:m,actions:oe,anchorEl:O.current,className:L.menu,disableAutoFocus:!!l,disableScrollLock:!!l,footer:B,getOptionDisabled:S,getOptionLabel:q,getOptionValue:U,groupBy:M,header:te,inlineSearch:l,loading:ee,open:!!se,options:C,paperRef:E,width:we,onChange:Le,onClose:Ie,onLoadMore:w,...F,ownerState:fe})]})};try{pe.displayName="Autocomplete",pe.__docgenInfo={description:"The autocomplete is used to choose an item from a collection of options.",displayName:"Autocomplete",props:{classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<AutocompleteClasses>"}},className:{defaultValue:null,description:"Class applied to the root element.",name:"className",required:!1,type:{name:"string"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},inlineSearch:{defaultValue:null,description:"If true, it is possible to enter a search string in the input itself.",name:"inlineSearch",required:!1,type:{name:"boolean"}},open:{defaultValue:null,description:"If true, the popper is opened.",name:"open",required:!1,type:{name:"boolean"}},onOpen:{defaultValue:null,description:"Callback fired when the menu requests to be opened.",name:"onOpen",required:!1,type:{name:"(() => void)"}},onClose:{defaultValue:null,description:"Callback fired when the menu requests to be closed.",name:"onClose",required:!1,type:{name:"(() => void)"}},onBlur:{defaultValue:null,description:"Callback fired when the input loses focus.",name:"onBlur",required:!1,type:{name:"((event: { target: { name?: string; }; }) => void)"}},MenuProps:{defaultValue:null,description:"Props applied to the menu component.",name:"MenuProps",required:!1,type:{name:'Partial<Omit<AutocompleteMenuProps<T>, "onChange" | "value" | "multiple" | "options" | "getOptionLabel" | "getOptionValue" | "getOptionDisabled" | "groupBy" | "getDisplayValue" | "actions">>'}},SearchProps:{defaultValue:null,description:"Props applied to the search field component. If present, shows the component.",name:"SearchProps",required:!1,type:{name:"Partial<FilledTextFieldProps | OutlinedTextFieldProps | StandardTextFieldProps>"}},multiple:{defaultValue:null,description:"",name:"multiple",required:!1,type:{name:"boolean"}},value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"T | T[] | null"}},onChange:{defaultValue:null,description:"",name:"onChange",required:!1,type:{name:"((value: T | null) => void) | ((value: T[]) => void)"}},getDisplayValue:{defaultValue:null,description:"",name:"getDisplayValue",required:!1,type:{name:"((value: T | null) => ReactNode) | ((value: T[]) => ReactNode)"}},footer:{defaultValue:null,description:"Children content for the menu footer.",name:"footer",required:!1,type:{name:"ReactNode"}},header:{defaultValue:null,description:"Children content for the menu header.",name:"header",required:!1,type:{name:"ReactNode"}},loading:{defaultValue:null,description:"If true, the component is in a loading state. This shows the labelLoading in place of options (only if options are empty).",name:"loading",required:!1,type:{name:"boolean"}},options:{defaultValue:null,description:"Array of the options.",name:"options",required:!0,type:{name:"T[]"}},getOptionLabel:{defaultValue:null,description:"Used to determine the display value for a given option. It's used to fill the input and the list box options.",name:"getOptionLabel",required:!0,type:{name:"(option: T) => ReactNode"}},getOptionValue:{defaultValue:null,description:"Used to determine the value for a given option. It's used for options comparison.",name:"getOptionValue",required:!0,type:{name:"(option: T) => string | number"}},getOptionDisabled:{defaultValue:null,description:"Used to determine the disabled state for a given option.",name:"getOptionDisabled",required:!1,type:{name:"((option: T) => boolean)"}},groupBy:{defaultValue:null,description:"If provided, the options will be grouped under the returned value.",name:"groupBy",required:!1,type:{name:"((option: T) => string | number)"}},MenuGroupProps:{defaultValue:null,description:"Props applied to the MenuGroup components.",name:"MenuGroupProps",required:!1,type:{name:"Partial<MenuGroupProps>"}},onLoadMore:{defaultValue:null,description:"Callback fired when the menu list is scrolled to the end.",name:"onLoadMore",required:!1,type:{name:"(() => void)"}}}}}catch{}function it(e){return J("ESAutocompleteField",e)}K("ESAutocompleteField",["root"]);const ut=e=>{const{classes:t}=e;return Q({root:["root"]},it,t)},pt=T(ze,{name:"ESAutocompleteField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),A=e=>{const{className:t,classes:o,sx:f,autoFocus:d,disabled:c,error:p,fullWidth:y,id:h,label:g,required:v,open:V,closeAfterSelect:C,helperText:U,size:q,InputProps:S,InputLabelProps:M,FormHelperTextProps:b,MenuGroupProps:ee,onChange:l,...te}=X({props:e,name:"ESAutocompleteField"}),[B,F]=Fe(!1,V),m=Be(h),D=U&&m?`${m}-helper-text`:void 0,R=g&&m?`${m}-label`:void 0,{onClose:x,onOpen:w,...j}=S||{},s=ut({classes:o}),O=E=>{l&&l(E),C&&(x==null||x(),F(!1))};return r.jsxs(pt,{className:z(s.root,We.root,t),disabled:c,error:p,focused:B||void 0,fullWidth:y,required:v,size:q,sx:f,children:[g!==null&&g!==""&&r.jsx(je,{htmlFor:m,id:R,required:v,...M,children:g}),r.jsx(pe,{MenuGroupProps:ee,"aria-describedby":D,autoFocus:d,disabled:c,fullWidth:y,id:m,label:g,open:B,required:v,onChange:O,onClose:()=>{x==null||x(),F(!1)},onOpen:()=>{w==null||w(),F(!0)},...te,...j}),!!U&&r.jsx($e,{id:D,...b,children:U})]})};try{A.displayName="AutocompleteField",A.__docgenInfo={description:"The autocomplete is used to choose an item from a collection of options.",displayName:"AutocompleteField",props:{classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<AutocompleteFieldClasses>"}},className:{defaultValue:null,description:"Class applied to the root element.",name:"className",required:!1,type:{name:"string"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},closeAfterSelect:{defaultValue:null,description:"If true, the popover will close after menu item is selected.",name:"closeAfterSelect",required:!1,type:{name:"boolean"}},helperText:{defaultValue:null,description:"The helper text content.",name:"helperText",required:!1,type:{name:"ReactNode"}},size:{defaultValue:null,description:"The size of the component.",name:"size",required:!1,type:{name:"enum",value:[{value:'"small"'},{value:'"medium"'}]}},InputProps:{defaultValue:null,description:"Props applied to the `Autocomplete` element.",name:"InputProps",required:!1,type:{name:'Partial<Omit<AutocompleteProps<T>, "onChange" | "value" | "multiple" | "options" | "getOptionLabel" | "getOptionValue" | "getOptionDisabled" | "groupBy" | "getDisplayValue">>'}},InputLabelProps:{defaultValue:null,description:"Props applied to the `InputLabel` element.",name:"InputLabelProps",required:!1,type:{name:'InputLabelProps<"label", {}>'}},FormHelperTextProps:{defaultValue:null,description:"Props applied to the `FormHelperText` element.",name:"FormHelperTextProps",required:!1,type:{name:'FormHelperTextProps<"p", {}>'}},value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"T | T[] | null"}},onChange:{defaultValue:null,description:"",name:"onChange",required:!1,type:{name:"((value: T | null) => void) | ((value: T[]) => void)"}},getDisplayValue:{defaultValue:null,description:"",name:"getDisplayValue",required:!1,type:{name:"((value: T | null) => ReactNode) | ((value: T[]) => ReactNode)"}},multiple:{defaultValue:null,description:"",name:"multiple",required:!1,type:{name:"boolean"}},footer:{defaultValue:null,description:"Children content for the menu footer.",name:"footer",required:!1,type:{name:"ReactNode"}},header:{defaultValue:null,description:"Children content for the menu header.",name:"header",required:!1,type:{name:"ReactNode"}},onBlur:{defaultValue:null,description:"Callback fired when the input loses focus.",name:"onBlur",required:!1,type:{name:"((event: { target: { name?: string; }; }) => void)"}},open:{defaultValue:null,description:"If true, the popper is opened.",name:"open",required:!1,type:{name:"boolean"}},loading:{defaultValue:null,description:"If true, the component is in a loading state. This shows the labelLoading in place of options (only if options are empty).",name:"loading",required:!1,type:{name:"boolean"}},options:{defaultValue:null,description:"Array of the options.",name:"options",required:!0,type:{name:"T[]"}},getOptionLabel:{defaultValue:null,description:"Used to determine the display value for a given option. It's used to fill the input and the list box options.",name:"getOptionLabel",required:!0,type:{name:"(option: T) => ReactNode"}},getOptionValue:{defaultValue:null,description:"Used to determine the value for a given option. It's used for options comparison.",name:"getOptionValue",required:!0,type:{name:"(option: T) => string | number"}},getOptionDisabled:{defaultValue:null,description:"Used to determine the disabled state for a given option.",name:"getOptionDisabled",required:!1,type:{name:"((option: T) => boolean)"}},groupBy:{defaultValue:null,description:"If provided, the options will be grouped under the returned value.",name:"groupBy",required:!1,type:{name:"((option: T) => string | number)"}},MenuGroupProps:{defaultValue:null,description:"Props applied to the MenuGroup components.",name:"MenuGroupProps",required:!1,type:{name:"Partial<MenuGroupProps>"}},inlineSearch:{defaultValue:null,description:"If true, it is possible to enter a search string in the input itself.",name:"inlineSearch",required:!1,type:{name:"boolean"}}}}}catch{}const P={en:[],ru:[]};for(let e=0;e<25;e++)P.en.push({id:e+1,name:`John Doe ${e+1}`}),P.ru.push({id:e+1,name:`Иванов Иван ${e+1}`});const Z=e=>e.id,de=e=>e.name,dt=e=>r.jsx("i",{children:e.name}),ct=e=>r.jsx("span",{children:e.map((t,o)=>r.jsxs(r.Fragment,{children:[r.jsx("i",{children:t.name},t.id),o<e.length-1&&", "]}))}),Bo={tags:["autodocs"],component:A,parameters:{references:["Autocomplete","AutocompleteField","MenuGroup"]},argTypes:{MenuGroupPaddingBottom:{name:"paddingBottom",description:"The bottom padding of the `MenuGroup` component.",table:{category:"MenuGroup",defaultValue:{summary:"l"}},options:["s","m","l"],control:{type:"select"}},MenuGroupSticky:{name:"sticky",description:"The sticky of the `MenuGroup` component.",table:{category:"MenuGroup"},control:{type:"boolean"}},multiple:{control:{type:"boolean"}},inlineSearch:{control:{type:"boolean"}},closeAfterSelect:{control:{type:"boolean"}},header:{control:{type:"text"}},footer:{control:{type:"text"}},disabled:{control:{type:"boolean"}},required:{control:{type:"boolean"}},error:{control:{type:"boolean"}},size:{options:["56","48","40","32"],control:{type:"select"}},helperText:{control:{type:"text"}},placeholder:{control:{type:"text"}},InputProps:{table:{disable:!0}},InputLabelProps:{table:{disable:!0}},FormHelperTextProps:{table:{disable:!0}},value:{table:{disable:!0}},getDisplayValue:{table:{disable:!0}},getOptionDisabled:{table:{disable:!0}},getOptionLabel:{table:{disable:!0}},getOptionValue:{table:{disable:!0}},loading:{table:{disable:!0}},options:{table:{disable:!0}}}},G={render:function(t,{globals:{locale:o}}){const[f,d]=n.useState([]),[c,p]=n.useState(!1),[y,h]=n.useState(null),[g,v]=n.useState([]),[V,C]=n.useState(""),U=b=>{h(b),t.inlineSearch&&b&&C(b.name)},q=b=>{v(b)};n.useEffect(()=>{d(P[o]),C(""),p(!1)},[o]);const S=n.useRef(null);n.useEffect(()=>(p(!0),S.current=setTimeout(()=>{d(P[o].filter(b=>b.name.toLowerCase().includes(V.toLowerCase()))),p(!1)},1e3),()=>{S.current&&(clearTimeout(S.current),S.current=null)}),[V]);const M={closeAfterSelect:t.closeAfterSelect,disabled:t.disabled,error:t.error,header:t.header&&r.jsx(ue,{children:t.header}),footer:t.footer&&r.jsx(ie,{children:t.footer}),fullWidth:!0,inlineSearch:t.inlineSearch,getOptionLabel:de,getOptionValue:Z,helperText:t.helperText,loading:c,options:f,placeholder:t.placeholder,required:t.required,size:t.size,InputProps:{SearchProps:{value:V,onChange:b=>C(b.target.value)}},onBlur:t.onBlur};return r.jsx(Y,{sx:{maxWidth:"500px"},children:t.multiple?r.jsx(A,{multiple:!0,label:o==="en"?"Users":"Пользователи",value:g,onChange:q,...M}):r.jsx(A,{label:o==="en"?"Users":"Пользователи",value:y,onChange:U,...M})})}},_={render:function(t,{globals:{locale:o}}){const[f,d]=n.useState([]),[c,p]=n.useState([]),y=h=>{p(h)};return n.useEffect(()=>{d(P[o])},[o]),r.jsx(Y,{sx:{maxWidth:"500px"},children:r.jsx(A,{fullWidth:!0,multiple:!0,MenuGroupProps:{paddingBottom:t.MenuGroupPaddingBottom,sticky:t.MenuGroupSticky},getOptionLabel:de,getOptionValue:Z,groupBy:h=>{const g=Math.floor(h.id/10);return`${g*10} - ${(g+1)*10-1}`},label:o==="en"?"Users":"Пользователи",options:f,value:c,onChange:y})})}},H={render:function(t,{globals:{locale:o}}){const[f,d]=n.useState([]),[c,p]=n.useState([]),y=h=>{p(h)};return n.useEffect(()=>{d(P[o])},[o]),r.jsx(Y,{sx:{maxWidth:"500px"},children:r.jsx(A,{fullWidth:!0,multiple:!0,getDisplayValue:ct,getOptionLabel:dt,getOptionValue:Z,label:o==="en"?"Users":"Пользователи",options:f,value:c,onChange:y})})}},$={render:function(t,{globals:{locale:o}}){const[f,d]=n.useState(!1),[c,p]=n.useState([]),[y,h]=n.useState([]),g=v=>{h(v)};return n.useEffect(()=>{p(P[o])},[o]),r.jsx(Y,{sx:{maxWidth:"500px"},children:r.jsx(A,{fullWidth:!0,multiple:!0,InputProps:{onOpen:()=>d(!0),onClose:()=>d(!1)},getOptionLabel:de,getOptionValue:Z,label:o==="en"?"Users":"Пользователи",open:f,options:c,value:y,onChange:g})})}};var ye,be,xe;G.parameters={...G.parameters,docs:{...(ye=G.parameters)==null?void 0:ye.docs,source:{originalSource:`{
  render: function Render(args: Args, {
    globals: {
      locale
    }
  }: StoryContext<unknown>) {
    const [options, setOptions] = useState<User[]>([]);
    const [loading, setLoading] = useState(false);
    const [user, setUser] = useState<User | null>(null);
    const [users, setUsers] = useState<User[]>([]);
    const [search, setSearch] = useState('');
    const onChange = (user: User | null) => {
      setUser(user);
      if (args.inlineSearch && user) {
        setSearch(user.name);
      }
    };
    const onChangeUsers = (users: User[]) => {
      setUsers(users);
    };
    useEffect(() => {
      setOptions(USERS[locale as 'en' | 'ru']);
      setSearch('');
      setLoading(false);
    }, [locale]);
    const timeout = useRef<ReturnType<typeof setTimeout> | null>(null);
    useEffect(() => {
      setLoading(true);
      timeout.current = setTimeout(() => {
        setOptions(USERS[locale as 'en' | 'ru'].filter(e => e.name.toLowerCase().includes(search.toLowerCase())));
        setLoading(false);
      }, 1000);
      return () => {
        if (timeout.current) {
          clearTimeout(timeout.current);
          timeout.current = null;
        }
      };
    }, [search]);
    const props: Pick<AutocompleteFieldProps<any>, 'closeAfterSelect' | 'disabled' | 'error' | 'inlineSearch' | 'header' | 'footer' | 'fullWidth' | 'getOptionLabel' | 'getOptionValue' | 'helperText' | 'loading' | 'options' | 'placeholder' | 'required' | 'size' | 'InputProps' | 'onBlur'> = {
      closeAfterSelect: args.closeAfterSelect,
      disabled: args.disabled,
      error: args.error,
      header: args.header && <AutocompleteMenuHeader>{args.header}</AutocompleteMenuHeader>,
      footer: args.footer && <AutocompleteMenuFooter>{args.footer}</AutocompleteMenuFooter>,
      fullWidth: true,
      inlineSearch: args.inlineSearch,
      getOptionLabel: getUserLabel,
      getOptionValue: getUserValue,
      helperText: args.helperText,
      loading,
      options,
      placeholder: args.placeholder,
      required: args.required,
      size: args.size,
      InputProps: {
        SearchProps: {
          value: search,
          onChange: e => setSearch(e.target.value)
        }
      },
      onBlur: args.onBlur
    };
    return <Box sx={{
      maxWidth: '500px'
    }}>
        {args.multiple ? <AutocompleteField<User> multiple label={locale === 'en' ? 'Users' : 'Пользователи'} value={users} onChange={onChangeUsers} {...props} /> : <AutocompleteField label={locale === 'en' ? 'Users' : 'Пользователи'} value={user} onChange={onChange} {...props} />}
      </Box>;
  }
}`,...(xe=(be=G.parameters)==null?void 0:be.docs)==null?void 0:xe.source}}};var ve,Se,Ae,Ve,Ce;_.parameters={..._.parameters,docs:{...(ve=_.parameters)==null?void 0:ve.docs,source:{originalSource:`{
  render: function Render(args: Args, {
    globals: {
      locale
    }
  }: StoryContext<unknown>) {
    const [options, setOptions] = useState<User[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const onChangeUsers = (users: User[]) => {
      setUsers(users);
    };
    useEffect(() => {
      setOptions(USERS[locale as 'en' | 'ru']);
    }, [locale]);
    return <Box sx={{
      maxWidth: '500px'
    }}>
        <AutocompleteField<User> fullWidth multiple MenuGroupProps={{
        paddingBottom: args.MenuGroupPaddingBottom,
        sticky: args.MenuGroupSticky
      }} getOptionLabel={getUserLabel} getOptionValue={getUserValue} groupBy={user => {
        const base = Math.floor(user.id / 10);
        return \`\${base * 10} - \${(base + 1) * 10 - 1}\`;
      }} label={locale === 'en' ? 'Users' : 'Пользователи'} options={options} value={users} onChange={onChangeUsers} />
      </Box>;
  }
}`,...(Ae=(Se=_.parameters)==null?void 0:Se.docs)==null?void 0:Ae.source},description:{story:"We can group the options with the `groupBy` prop. Make sure that the options are also sorted with the same dimension that they are grouped by, otherwise, you will notice duplicate headers.",...(Ce=(Ve=_.parameters)==null?void 0:Ve.docs)==null?void 0:Ce.description}}};var Ue,Oe,Pe;H.parameters={...H.parameters,docs:{...(Ue=H.parameters)==null?void 0:Ue.docs,source:{originalSource:`{
  render: function Render(_args: Args, {
    globals: {
      locale
    }
  }: StoryContext<unknown>) {
    const [options, setOptions] = useState<User[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const onChangeUsers = (users: User[]) => {
      setUsers(users);
    };
    useEffect(() => {
      setOptions(USERS[locale as 'en' | 'ru']);
    }, [locale]);
    return <Box sx={{
      maxWidth: '500px'
    }}>
        <AutocompleteField<User> fullWidth multiple getDisplayValue={getUsersDisplayValue} getOptionLabel={getUserLabelReactNode} getOptionValue={getUserValue} label={locale === 'en' ? 'Users' : 'Пользователи'} options={options} value={users} onChange={onChangeUsers} />
      </Box>;
  }
}`,...(Pe=(Oe=H.parameters)==null?void 0:Oe.docs)==null?void 0:Pe.source}}};var Te,qe,Me;$.parameters={...$.parameters,docs:{...(Te=$.parameters)==null?void 0:Te.docs,source:{originalSource:`{
  render: function Render(_args: Args, {
    globals: {
      locale
    }
  }: StoryContext<unknown>) {
    const [open, setOpen] = useState(false);
    const [options, setOptions] = useState<User[]>([]);
    const [users, setUsers] = useState<User[]>([]);
    const onChangeUsers = (users: User[]) => {
      setUsers(users);
    };
    useEffect(() => {
      setOptions(USERS[locale as 'en' | 'ru']);
    }, [locale]);
    return <Box sx={{
      maxWidth: '500px'
    }}>
        <AutocompleteField<User> fullWidth multiple InputProps={{
        onOpen: () => setOpen(true),
        onClose: () => setOpen(false)
      }} getOptionLabel={getUserLabel} getOptionValue={getUserValue} label={locale === 'en' ? 'Users' : 'Пользователи'} open={open} options={options} value={users} onChange={onChangeUsers} />
      </Box>;
  }
}`,...(Me=(qe=$.parameters)==null?void 0:qe.docs)==null?void 0:Me.source}}};const Do=["Demo","Groups","Customization","Controlled"];export{$ as Controlled,H as Customization,G as Demo,_ as Groups,Do as __namedExportsOrder,Bo as default};
