import{j as c}from"./jsx-runtime-BoZ7yaty.js";import{r as u}from"./index-DIDRz_s2.js";import{c as M}from"./clsx.m-C7bORDfW.js";import{g as me,a as he,s as y,c as ve}from"./styled-B0X8gopH.js";import{u as Se}from"./useThemeProps-DTzdApbH.js";import{u as Oe}from"./useTheme-D4EsW5Cf.js";import{I as it}from"./IconChevronLeftW400-zAg2tq5A.js";import{I as ct}from"./IconChevronRightW400-BtXqwoZd.js";import{c as Xe}from"./identifier-DA8c-tJk.js";import{B as Ue,b as W}from"./ButtonBase-C33Z4or-.js";import{d as P,D as Ye}from"./Divider-DdtDcetk.js";import{u as pe}from"./useEventCallback-B5h_k30D.js";import{o as Ke}from"./ownerWindow-HkKU3E4x.js";import{d as Ge}from"./debounce-Be36O1Ab.js";import{o as dt}from"./ownerDocument-DW-IO8s5.js";import{k as ut}from"./emotion-react.browser.esm-BV4sMx87.js";import{u as pt}from"./useEnhancedEffect-BGNjlb7u.js";import{I as ke}from"./IconAt-BTb7PeT6.js";import"./_commonjsHelpers-gnU0ypJ3.js";import"./useTheme-B2nYkSwK.js";import"./SvgIcon-BU7TD1_e.js";import"./SvgIcon.classes-C7Fm2IhD.js";import"./useForkRef-DJnV46t9.js";function bt(e){return he("ESTab",e)}const $=me("ESTab",["root","labelIcon","labelWrapper","selected","disabled","fullWidth","rounded","startIcon","endIcon"]),ft=e=>{const{classes:t,fullWidth:l,icon:d,label:r,rounded:f,selected:m,disabled:b}=e;return ve({root:["root",d&&r&&"labelIcon",l&&"fullWidth",f&&"rounded",m&&"selected",b&&"disabled","labelWrapper"],startIcon:["startIcon"],endIcon:["endIcon"]},bt,t)},mt=y(Ue,{name:"ESTab",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:l}=e;return[t.root,l.label&&l.icon&&t.labelIcon,l.fullWidth&&t.fullWidth,l.rounded&&t.rounded]}})(({theme:e})=>({maxWidth:360,minWidth:90,minHeight:48,position:"relative",flexShrink:0,padding:"8px 8px",overflow:"hidden",fontFamily:"inherit","--text":e.vars.palette.monoA.A700,"--hovered":e.vars.palette.monoA.A50,"--pressed":e.vars.palette.monoA.A150,"--focused":e.vars.palette.monoA.A200,[`&:not(.${W.disabled}):focus-visible`]:{outline:"none",boxShadow:`inset 0 0 0 2px ${e.vars.palette.monoA[500]}`},[`& .${W.wrapper}`]:{gap:8},[`&.${$.selected}`]:{"--text":e.vars.palette.monoA.A900,[`& .${W.wrapper} .${$.startIcon}, & .${W.wrapper} .${$.endIcon}`]:{color:e.vars.palette.monoA.A800}},[`&.${$.rounded}`]:{minHeight:"inherit",maxHeight:36,borderRadius:4,marginTop:6,marginBottom:6},[`&.${$.fullWidth}`]:{flexShrink:1,flexGrow:1,flexBasis:0,maxWidth:"none"},[`&.${W.disabled}`]:{"--text":e.vars.palette.monoA.A400},[`& .${W.wrapper} .${$.startIcon}, & .${W.wrapper} .${$.endIcon}`]:{color:e.vars.palette.monoA.A600}})),ht=y("span",{name:"ESTab",slot:"LabelWrapper",overridesResolver:(e,t)=>[t.labelWrapper]})(({theme:e})=>({textAlign:"center",textOverflow:"ellipsis",overflow:"hidden",whiteSpace:"nowrap",...e.typography.body100})),vt=y("span",{name:"ESTab",slot:"StartIcon",overridesResolver:(e,t)=>[t.startIcon]})(()=>({display:"inherit"})),St=y("span",{name:"ESTab",slot:"EndIcon",overridesResolver:(e,t)=>[t.endIcon]})(()=>({display:"inherit"})),be=u.forwardRef(function(t,l){const{className:d,disabled:r=!1,disableFocusRipple:f=!0,fullWidth:m,startIcon:b,endIcon:h,indicator:g,label:T,onChange:v,onClick:N,onFocus:_,rounded:V,selected:q,selectionFollowsFocus:Y,value:H,...z}=Se({props:t,name:"ESTab"}),K={...z,disabled:r,disableFocusRipple:f,rounded:V,selected:q,startIcon:b,endIcon:h,icon:!!b||!!h,label:!!T,fullWidth:m},I=ft(K),O=x=>{!q&&v&&v(x,H),N&&N(x)},D=x=>{Y&&!q&&v&&v(x,H),_&&_(x)};return c.jsxs(mt,{ref:l,"aria-selected":q,className:M(I.root,d),disabled:r,ownerState:K,role:"tab",tabIndex:q?0:-1,onClick:O,onFocus:D,...z,children:[!!b&&c.jsx(vt,{className:I.startIcon,children:b}),c.jsx(ht,{children:T}),!!h&&c.jsx(St,{className:I.endIcon,children:h}),g]})});try{be.displayName="Tab",be.__docgenInfo={description:"",displayName:"Tab",props:{children:{defaultValue:null,description:"This prop isn't supported.\nUse the `component` prop if you need to change the children structure.",name:"children",required:!1,type:{name:"null"}},classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<TabClasses>"}},disabled:{defaultValue:{value:"false"},description:"If `true`, the component is disabled.",name:"disabled",required:!1,type:{name:"boolean"}},disableFocusRipple:{defaultValue:{value:"true"},description:"If `true`, the  keyboard focus ripple is disabled.",name:"disableFocusRipple",required:!1,type:{name:"boolean"}},label:{defaultValue:null,description:"The label element.",name:"label",required:!1,type:{name:"ReactNode"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},value:{defaultValue:null,description:"You can provide your own value. Otherwise, we fallback to the child position index.",name:"value",required:!1,type:{name:"any"}},rounded:{defaultValue:null,description:"If 'true' the component will be smaller and have rounded corners.",name:"rounded",required:!1,type:{name:"boolean"}},className:{defaultValue:null,description:"CSS class to be applied to the root element of the component.",name:"className",required:!1,type:{name:"string"}},indicator:{defaultValue:null,description:"The indicator element for the current tab.",name:"indicator",required:!1,type:{name:"ReactElement<any, string | JSXElementConstructor<any>>"}},fullWidth:{defaultValue:null,description:"If `true`, the component will take up the full available width.",name:"fullWidth",required:!1,type:{name:"boolean"}},onChange:{defaultValue:null,description:"Event handler for tab selection change. Accepts parameters: event and tab value.",name:"onChange",required:!1,type:{name:"((event: MouseEvent<Element, MouseEvent> | FocusEvent<Element, Element>, value: any) => void)"}},onClick:{defaultValue:null,description:"Event handler for tab click. Accepts parameter: click event.",name:"onClick",required:!1,type:{name:"((event: MouseEvent<Element, MouseEvent>) => void)"}},onFocus:{defaultValue:null,description:"Event handler for tab focus. Accepts parameter: focus event.",name:"onFocus",required:!1,type:{name:"((event: FocusEvent<Element, Element>) => void)"}},selectionFollowsFocus:{defaultValue:null,description:"Determines whether the tab should be selected when focused. If `true`, selection will change when the tab is focused.",name:"selectionFollowsFocus",required:!1,type:{name:"boolean"}},selected:{defaultValue:null,description:"If `true`, the tab will be selected.",name:"selected",required:!1,type:{name:"boolean"}},startIcon:{defaultValue:null,description:"Element placed before the children.",name:"startIcon",required:!1,type:{name:"ReactNode"}},endIcon:{defaultValue:null,description:"Element placed after the children.",name:"endIcon",required:!1,type:{name:"ReactNode"}}}}}catch{}function yt(e){return he("ESTabs",e)}const oe=me("ESTabs",["root","flexContainer","centered","scroller","fixed","scrollableX","hideScrollbar","scrollButtons","scrollButtonsHideMobile","tabsDivider","indicator"]),gt=e=>(1+Math.sin(Math.PI*e-Math.PI/2))/2,Tt=(e,t,l,d)=>{const{ease:r=gt,duration:f=300}=d;let m=null;const b=t[e];let h=!1;const g=()=>{h=!0},T=v=>{if(h)return;m===null&&(m=v);const N=Math.min(1,(v-m)/f);t[e]=r(N)*(l-b)+b,N<1&&requestAnimationFrame(T)};return b===l||requestAnimationFrame(T),g};function wt(e){return he("ESTabScrollButton",e)}const C=me("ESTabScrollButton",["root","disabled","directionLeft","directionRight","icon","gradient","divider"]),It=e=>{const{classes:t,disabled:l,direction:d}=e,r={root:["root",l&&"disabled",`direction${Xe(d)}`],icon:["icon"],gradient:["gradient"],divider:["divider"]};return ve(r,wt,t)},xt=y(Ue,{name:"ESTabScrollButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:l}=e;return[t.root,l.disabled&&t.disabled,t[`direction${Xe(l.direction)}`]]}})(({theme:e})=>({position:"absolute",width:40,height:"var(--tab-list-height)",flexShrink:0,zIndex:2,overflow:"visible","--background":e.vars.palette.monoB.main,"--hovered":e.vars.palette.monoA.A50,"--pressed":e.vars.palette.monoA.A150,"--focused":e.vars.palette.monoA.A200,[`&.${C.disabled}`]:{opacity:0},[`&.${C.directionLeft}`]:{left:"-1px",[`& .${C.divider}.${P.vertical}.${P.flexItem}`]:{left:"11.5px"},[`& .${C.gradient}`]:{background:`linear-gradient(90deg, ${e.vars.palette.monoB.main} 0%, rgba(255, 255, 255, 0) 100%)`,left:"11px"},[`& .${C.icon}`]:{left:"5px"}},[`&.${C.directionRight}`]:{right:"0px",[`& .${C.divider}.${P.vertical}.${P.flexItem}`]:{right:"11.5px"},[`& .${C.gradient}`]:{background:`linear-gradient(270deg, ${e.vars.palette.monoB.main} 0%, rgba(255, 255, 255, 0) 100%)`,right:"11px"},[`& .${C.icon}`]:{right:"5px"}}})),We=y(Ye,{name:"ESTabScrollButton",slot:"Divider",overridesResolver:(e,t)=>[t.divider]})(()=>({[`&.${P.vertical}.${P.flexItem}`]:{position:"relative",alignSelf:"center",height:"75%"}})),$e=y("div",{name:"ESTabScrollButton",slot:"Gradient",overridesResolver:(e,t)=>[t.gradient]})(()=>({position:"relative",width:8,height:"100%"})),Me=y("span",{name:"ESTabScrollButton",slot:"Icon",overridesResolver:(e,t)=>[t.icon]})(()=>({display:"inline-flex",position:"relative"})),fe=u.forwardRef(function(t,l){const{className:d,direction:r,slots:f={},tabListHeight:m,...b}=Se({props:t,name:"ESTabScrollButton"}),h=Oe(),T={isRtl:h.direction==="rtl",direction:r,tabListHeight:m,...b},v=It(T);return c.jsx(xt,{ref:l,className:M(v.root,d),component:"div",ownerState:T,style:{"--tab-list-height":`${m}px`},...b,children:r==="left"?c.jsxs(c.Fragment,{children:[c.jsx(Me,{className:v.icon,children:f.StartScrollButtonIcon?f.StartScrollButtonIcon:c.jsx(it,{sx:{color:h.vars.palette.monoA.A600}})}),c.jsx(We,{flexItem:!0,className:v.divider,orientation:"vertical"}),c.jsx($e,{className:v.gradient})]}):c.jsxs(c.Fragment,{children:[c.jsx($e,{className:v.gradient}),c.jsx(We,{flexItem:!0,className:v.divider,orientation:"vertical"}),c.jsx(Me,{className:v.icon,children:f.EndScrollButtonIcon?f.EndScrollButtonIcon:c.jsx(ct,{sx:{color:h.vars.palette.monoA.A600}})})]})})});try{fe.displayName="TabScrollButton",fe.__docgenInfo={description:"",displayName:"TabScrollButton",props:{children:{defaultValue:null,description:"The content of the component.",name:"children",required:!1,type:{name:"ReactNode"}},classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<TabScrollButtonClasses>"}},className:{defaultValue:null,description:"The CSS class applied to the root element.",name:"className",required:!1,type:{name:"string"}},direction:{defaultValue:null,description:"The direction the button should indicate.",name:"direction",required:!0,type:{name:"enum",value:[{value:'"left"'},{value:'"right"'}]}},disabled:{defaultValue:null,description:"If `true`, the component is disabled.",name:"disabled",required:!1,type:{name:"boolean"}},tabListHeight:{defaultValue:null,description:"The height of the list of tabs.",name:"tabListHeight",required:!1,type:{name:"number"}},slots:{defaultValue:{value:"{}"},description:"The components used for each slot inside.",name:"slots",required:!1,type:{name:"{ StartScrollButtonIcon?: ReactNode; EndScrollButtonIcon?: ReactNode; }"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}}}}}catch{}const Et=ut`
  0% {
    transform: scaleX(0);
  }
  100% {
    transform: scaleX(1);
  }
`,Bt=({onChange:e,style:t,...l})=>{const d=u.useRef(0),r=u.useRef(null),f=()=>{r.current&&(d.current=r.current.offsetHeight-r.current.clientHeight)};return pt(()=>{if(r.current&&d.current){const m=Ge(()=>{const h=d.current;f(),h!==d.current&&e(d.current)}),b=Ke(r.current);return b.addEventListener("resize",m),()=>{m.clear(),b.removeEventListener("resize",m)}}},[e]),u.useEffect(()=>{f(),e(d.current)},[e]),c.jsx("div",{ref:r,style:{width:99,height:99,position:"absolute",top:-9999,overflow:"scroll",...t},...l})},De=(e,t)=>e===t?e.firstChild:t&&t.nextElementSibling?t.nextElementSibling:e.firstChild,Fe=(e,t)=>e===t?e.lastChild:t&&t.previousElementSibling?t.previousElementSibling:e.lastChild,te=(e,t,l)=>{let d=!1,r=t&&l(e,t);for(;r;){if(r===e.firstChild){if(d)return;d=!0}const f=r.getAttribute("aria-disabled")==="true";if(!r.hasAttribute("tabindex")||f)r=l(e,r);else{r.focus();return}}},Ct=e=>{const{fixed:t,hideScrollbar:l,scrollableX:d,centered:r,scrollButtonsHideMobile:f,classes:m}=e;return ve({root:["root"],scroller:["scroller",t&&"fixed",l&&"hideScrollbar",d&&"scrollableX"],flexContainer:["flexContainer",r&&"centered"],indicator:["indicator"],scrollButtons:["scrollButtons",f&&"scrollButtonsHideMobile"],scrollableX:[d&&"scrollableX"],hideScrollbar:[l&&"hideScrollbar"],tabsDivider:["tabsDivider"]},yt,m)},Rt=y("div",{name:"ESTabs",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:l}=e;return[{[`& .${oe.scrollButtons}`]:t.scrollButtons},{[`& .${oe.scrollButtons}`]:l.scrollButtonsHideMobile&&t.scrollButtonsHideMobile},t.root]}})(({theme:e})=>({position:"relative",overflow:"hidden",minHeight:48,WebkitOverflowScrolling:"touch",display:"flex",variants:[{props:{scrollButtonsHideMobile:!0},style:{[`& .${oe.scrollButtons}`]:{[e.breakpoints.down("tabletXS")]:{display:"none"}}}}]})),At=y("div",{name:"ESTabs",slot:"Scroller",overridesResolver:(e,t)=>{const{ownerState:l}=e;return[t.scroller,l.fixed&&t.fixed,l.hideScrollbar&&t.hideScrollbar,l.scrollableX&&t.scrollableX,l.scrollableY&&t.scrollableY]}})(()=>({position:"relative",display:"inline-block",flex:"1 1 auto",whiteSpace:"nowrap",variants:[{props:{overflow:"visible"},style:{overflow:"visible"}},{props:{overflow:"hidden"},style:{overflow:"hidden"}},{props:{overflow:"clip"},style:{overflow:"clip"}},{props:{overflow:"scroll"},style:{overflow:"scroll"}},{props:{overflow:"auto"},style:{overflow:"auto"}},{props:{visibleScrollbar:!0},style:{marginBottom:"var(--ESTabs-scrollbarWidth)"}},{props:{fixed:!0},style:{overflowX:"hidden",width:"100%"}},{props:{hideScrollbar:!0},style:{scrollbarWidth:"none","&::-webkit-scrollbar":{display:"none"}}},{props:{scrollableX:!0},style:{overflowX:"auto",overflowY:"hidden"}}]})),Vt=y("div",{name:"ESTabs",slot:"FlexContainer",overridesResolver:(e,t)=>{const{ownerState:l}=e;return[t.flexContainer,l.centered&&t.centered]}})(()=>({display:"flex",padding:"0 16px",variants:[{props:{centered:!0},style:{justifyContent:"center"}}]})),Nt=y("span",{name:"ESTabs",slot:"Indicator",overridesResolver:(e,t)=>t.indicator})(({theme:e})=>({position:"absolute",height:2,variants:[{props:{TabIndicatorSlidingAnimation:"expand"},style:{animationName:Et,animationDuration:"200ms"}},{props:{TabIndicatorSlidingAnimation:"slide"},style:{transition:e.transitions.create(["left","right","width"],{duration:"200ms"})}},{props:{TabIndicatorPosition:"bottom"},style:{bottom:0}},{props:{TabIndicatorPosition:"top"},style:{top:0}},{props:{indicatorColor:"primary"},style:{backgroundColor:e.vars.palette.primary[300]}},{props:{indicatorColor:"secondary"},style:{backgroundColor:e.vars.palette.secondary[300]}}]})),qt=y(Bt)({overflowX:"auto",overflowY:"hidden",scrollbarWidth:"none","&::-webkit-scrollbar":{display:"none"}}),kt=y(Ye,{name:"ESTabs",slot:"TabsDivider",overridesResolver:(e,t)=>[t.tabsDivider]})(({theme:e})=>({position:"absolute",zIndex:3,width:"100%",borderColor:e.vars.palette.monoA.A100,variants:[{props:{TabIndicatorPosition:"bottom"},style:{bottom:0}},{props:{TabIndicatorPosition:"top"},style:{top:0}}]})),je={};let Le=!1;const le=u.forwardRef(function(t,l){const{"aria-label":d,"aria-labelledby":r,action:f,centered:m=!1,children:b,className:h,component:g="div",allowScrollButtonsMobile:T=!1,indicatorColor:v="primary",onChange:N,ScrollButtonComponent:_=fe,scrollButtons:V="auto",selectionFollowsFocus:q,slots:Y={},TabIndicatorAlignment:H="center",TabIndicatorSlidingAnimation:z="slide",TabIndicatorPosition:K="bottom",TabIndicatorWidth:I="100%",TabIndicatorProps:O={},TabScrollButtonProps:D={},value:x,variant:ae="standard",visibleScrollbar:ye=!1,...re}=Se({props:t,name:"ESTabs"}),ge=Oe(),F=ge.direction==="rtl",E=ae==="scrollable",X="scrollLeft",G="left",J="right",se="clientWidth",R="width",k=F?"right":"left";m&&E&&console.error('You can not use the `centered={true}` and `variant="scrollable"` properties at the same time on a `Tabs` component.');const[Te,Je]=u.useState(!1),[B,we]=u.useState(je),[Ie,Qe]=u.useState(!1),[xe,Ze]=u.useState(!1),[Ee,et]=u.useState(!1),[Be,tt]=u.useState({overflow:"hidden",scrollbarWidth:0}),Ce=new Map,S=u.useRef(null),w=u.useRef(null),j={...re,component:g,allowScrollButtonsMobile:T,indicatorColor:v,scrollButtons:V,overflow:Be.overflow,variant:ae,visibleScrollbar:ye,fixed:!E,hideScrollbar:E&&!ye,scrollableX:!!E,centered:m&&!E,scrollButtonsHideMobile:!T,TabIndicatorPosition:K,TabIndicatorSlidingAnimation:z},A=Ct(j),Re=()=>{const o=S.current;let n;if(o){const s=o.getBoundingClientRect();n={clientWidth:o.clientWidth,scrollLeft:o.scrollLeft,scrollTop:o.scrollTop,scrollWidth:o.scrollWidth,top:s.top,bottom:s.bottom,left:s.left,right:s.right}}let a;if(w.current&&o&&x!==!1){const s=w.current.children;if(s.length>0){const i=s[Ce.get(x)];a=i?i.getBoundingClientRect():null,n&&!Le&&a&&a.width===0&&a.height===0&&n.clientWidth!==0&&(n=null,console.error(["The `value` provided to the Tabs component is invalid.",`The Tab with this \`value\` ("${x}") is not part of the document layout.`,"Make sure the tab item is present in the document or that it's not `display: none`."].join(`
`)),Le=!0)}}return{tabsMeta:n,tabMeta:a}},U=pe(()=>{const{tabsMeta:o,tabMeta:n}=Re();let a=0,s=0;if(n&&o&&(a=(F?-1:1)*(n[k]-o[k]+o.scrollLeft)),n&&B[R]&&H){const p=n[R]-B[R];switch(H){case"center":a+=p/2;break;case"right":a+=p}}if(I){const p=I.includes("px"),L=I.includes("%"),de=+I.split("px")[0],ee=+I.split("%")[0]/100*(n?n[R]:0);s=p?de:L?ee:+I}const i={[k]:a,[R]:n?I?s:n[R]:0};if(isNaN(B[k])||isNaN(B[R]))we(i);else{const p=Math.abs(B[k]-i[k]),L=Math.abs(B[R]-i[R]);(p>=1||L>=1)&&we(i)}}),ie=(o,{animation:n=!0}={})=>{n&&S.current?Tt(X,S.current,o,{duration:ge.transitions.duration.standard}):S.current&&(S.current[X]=o)},Ae=o=>{if(S.current){let n=S.current[X];n+=o*(F?-1:1),ie(n)}},Ve=()=>{if(S.current&&w.current){const o=S.current[se];let n=0;const a=Array.from(w.current.children);for(let s=0;s<a.length;s+=1){const i=a[s];if(n+i[se]>o){s===0&&(n=o);break}n+=i[se]}return n}return 0},nt=()=>{Ae(-1*Ve())},ot=()=>{Ae(Ve())},lt=u.useCallback(o=>{tt({overflow:null,scrollbarWidth:o})},[]),at=()=>{var i;const o={scrollbarSizeListener:null,scrollButtonStart:null,scrollButtonEnd:null};o.scrollbarSizeListener=E?c.jsx(qt,{className:M(A.scrollableX,A.hideScrollbar),onChange:lt}):null;const a=E&&(V==="auto"&&(Ie||xe)||V===!0),s=(i=w.current)==null?void 0:i.clientHeight;return o.scrollButtonStart=a?c.jsx(_,{direction:F?"right":"left",disabled:!Ie,slots:{StartScrollButtonIcon:Y.StartScrollButtonIcon},tabListHeight:s,onClick:nt,...D,className:M(A.scrollButtons,D.className)}):null,o.scrollButtonEnd=a?c.jsx(_,{direction:F?"left":"right",disabled:!xe,slots:{EndScrollButtonIcon:Y.EndScrollButtonIcon},tabListHeight:s,onClick:ot,...D,className:M(A.scrollButtons,D.className)}):null,o},Ne=pe(o=>{var i;const{tabsMeta:n,tabMeta:a}=Re(),s=(i=document.querySelector(`.${C.root}`))==null?void 0:i.getBoundingClientRect().width;if(!(!a||!n)){if(a[G]<n[G]){const p=n[X]+(a[G]-n[G]);ie(p-(s||0),{animation:o})}else if(a[J]>n[J]){const p=n[X]+(a[J]-n[J]);ie(p+(s||0),{animation:o})}}}),Q=pe(()=>{E&&V!==!1&&et(!Ee)});u.useEffect(()=>{const o=Ge(()=>{S.current&&U()});let n;const a=s=>{s.forEach(i=>{i.removedNodes.forEach(p=>{p.nodeType===Node.ELEMENT_NODE&&(n==null||n.unobserve(p))}),i.addedNodes.forEach(p=>{p.nodeType===Node.ELEMENT_NODE&&(n==null||n.observe(p))})}),o(),Q()};if(S.current&&w.current){const s=Ke(S.current);s.addEventListener("resize",o);let i;return typeof ResizeObserver<"u"&&(n=new ResizeObserver(o),Array.from(w.current.children).forEach(p=>{n.observe(p)})),typeof MutationObserver<"u"&&(i=new MutationObserver(a),i.observe(w.current,{childList:!0})),()=>{o.clear(),s.removeEventListener("resize",o),i==null||i.disconnect(),n==null||n.disconnect()}}},[U,Q]),u.useEffect(()=>{if(w.current){const o=Array.from(w.current.children),n=o.length;if(typeof IntersectionObserver<"u"&&n>0&&E&&V!==!1){const a=o[0],s=o[n-1],i={root:S.current,threshold:.99},p=ue=>{Qe(!ue[0].isIntersecting)},L=new IntersectionObserver(p,i);L.observe(a);const de=ue=>{Ze(!ue[0].isIntersecting)},ee=new IntersectionObserver(de,i);return ee.observe(s),()=>{L.disconnect(),ee.disconnect()}}return}},[E,V,Ee,b]),u.useEffect(()=>{Je(!0)},[]),u.useEffect(()=>{U()}),u.useEffect(()=>{Ne(je!==B)},[Ne,B]),u.useImperativeHandle(f,()=>({updateIndicator:U,updateScrollButtons:Q}),[U,Q]);const qe=c.jsx(Nt,{...O,className:M(A.indicator,O.className),ownerState:j,style:{...B,...O.style}},z==="expand"?B[k]:void 0);let Z=0;const rt=u.Children.map(b,o=>{if(!u.isValidElement(o))return null;const n=o.props.value===void 0?Z:o.props.value;Ce.set(n,Z);const a=n===x;return Z+=1,u.cloneElement(o,{fullWidth:ae==="fullWidth",indicator:a&&!Te&&qe,selected:a,selectionFollowsFocus:q,onChange:N,rounded:re.rounded,value:n,...Z===1&&x===!1&&!o.props.tabIndex?{tabIndex:0}:{}})}),st=o=>{if(w.current){const n=w.current,a=dt(n).activeElement;if(a.getAttribute("role")!=="tab")return;let i="ArrowLeft",p="ArrowRight";switch(F&&(i="ArrowRight",p="ArrowLeft"),o.key){case i:o.preventDefault(),te(n,a,Fe);break;case p:o.preventDefault(),te(n,a,De);break;case"Home":o.preventDefault(),te(n,null,De);break;case"End":o.preventDefault(),te(n,null,Fe);break}}},ce=at();return c.jsxs(Rt,{ref:l,as:g,className:M(A.root,h),ownerState:j,...re,style:{"--ESTabs-scrollbarWidth":`-${Be.scrollbarWidth}px`},children:[ce.scrollButtonStart,ce.scrollbarSizeListener,c.jsxs(At,{ref:S,className:A.scroller,ownerState:j,children:[c.jsx(Vt,{ref:w,"aria-label":d,"aria-labelledby":r,className:A.flexContainer,ownerState:j,role:"tablist",onKeyDown:st,children:rt}),Te&&qe]}),c.jsx(kt,{className:A.tabsDivider,ownerState:j}),ce.scrollButtonEnd]})});try{le.displayName="Tabs",le.__docgenInfo={description:"",displayName:"Tabs",props:{action:{defaultValue:null,description:"Callback fired when the component mounts.\nThis is useful when you want to trigger an action programmatically.\nIt supports two actions: `updateIndicator()` and `updateScrollButtons()`\n@param actions This object contains all possible actions\nthat can be triggered programmatically.",name:"action",required:!1,type:{name:"RefObject<{ updateIndicator: () => void; updateScrollButtons: () => void; }>"}},allowScrollButtonsMobile:{defaultValue:{value:"false"},description:"If `true`, the scroll buttons aren't forced hidden on mobile.\nBy default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.",name:"allowScrollButtonsMobile",required:!1,type:{name:"boolean"}},"aria-label":{defaultValue:null,description:"The label for the Tabs as a string.",name:"aria-label",required:!1,type:{name:"string"}},"aria-labelledby":{defaultValue:null,description:"An id or list of ids separated by a space that label the Tabs.",name:"aria-labelledby",required:!1,type:{name:"string"}},centered:{defaultValue:{value:"false"},description:"If `true`, the tabs are centered.\nThis prop is intended for large views.",name:"centered",required:!1,type:{name:"boolean"}},children:{defaultValue:null,description:"The content of the component.",name:"children",required:!1,type:{name:"ReactNode"}},classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<TabsClasses>"}},className:{defaultValue:null,description:"@ignore",name:"className",required:!1,type:{name:"string"}},component:{defaultValue:null,description:`The component used for the root node.
Either a string to use a HTML element or a component.`,name:"component",required:!1,type:{name:"ElementType<any, keyof IntrinsicElements>"}},indicatorColor:{defaultValue:{value:"'primary'"},description:"Determines the color of the indicator.",name:"indicatorColor",required:!1,type:{name:"enum",value:[{value:'"secondary"'},{value:'"primary"'}]}},onChange:{defaultValue:null,description:`Callback fired when the value changes.
@param event The event source of the callback. **Warning**: This is a generic event not a change event.
@param value We default to the index of the child (number)`,name:"onChange",required:!1,type:{name:"((event: SyntheticEvent<Element, Event>, value: any) => void)"}},ScrollButtonComponent:{defaultValue:{value:"TabScrollButton"},description:"The component used to render the scroll buttons.",name:"ScrollButtonComponent",required:!1,type:{name:"ElementType<any, keyof IntrinsicElements>"}},scrollButtons:{defaultValue:{value:"'auto'"},description:"Determine behavior of scroll buttons when tabs are set to scroll:\n\n- `auto` will only present them when not all the items are visible.\n- `true` will always present them.\n- `false` will never present them.\n\nBy default the scroll buttons are hidden on mobile.\nThis behavior can be disabled with `allowScrollButtonsMobile`.",name:"scrollButtons",required:!1,type:{name:'boolean | "auto"'}},selectionFollowsFocus:{defaultValue:null,description:"If `true` the selected tab changes on focus. Otherwise it only\nchanges on activation.",name:"selectionFollowsFocus",required:!1,type:{name:"boolean"}},slots:{defaultValue:{value:"{}"},description:"The components used for each slot inside.",name:"slots",required:!1,type:{name:"{ StartScrollButtonIcon?: ElementType<any, keyof IntrinsicElements>; EndScrollButtonIcon?: ElementType<any, keyof IntrinsicElements>; } | undefined"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},rounded:{defaultValue:null,description:"If 'true' each nested Tab component will be smaller and have rounded corners.",name:"rounded",required:!1,type:{name:"boolean"}},TabIndicatorSlidingAnimation:{defaultValue:{value:"'slide'"},description:"The transition used for TabIndicator sliding between Tabs.",name:"TabIndicatorSlidingAnimation",required:!1,type:{name:"enum",value:[{value:'"expand"'},{value:'"slide"'}]}},TabIndicatorAlignment:{defaultValue:{value:"'left'"},description:"Determines horizontal alignment of TabIndicator component:\n\n - `left` TabIndicator will be at the left side of Tab.\n - `center` TabIndicator will be at the center of the Tab.\n - `right` TabIndicator will be at the right side of the Tab.",name:"TabIndicatorAlignment",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"left"'},{value:'"right"'}]}},TabIndicatorPosition:{defaultValue:{value:"'bottom'"},description:"Determines position of TabIndicator component:\n\n - `top` TabIndicator will be at the top of the Tab.\n - `bottom` TabIndicator will be at the bottom of the Tab.",name:"TabIndicatorPosition",required:!1,type:{name:"enum",value:[{value:'"bottom"'},{value:'"top"'}]}},TabIndicatorProps:{defaultValue:{value:"{}"},description:`/**
  Props applied to the tab indicator element.`,name:"TabIndicatorProps",required:!1,type:{name:"HTMLAttributes<HTMLDivElement>"}},TabIndicatorWidth:{defaultValue:{value:"'100%'"},description:`Determines width of TabIndicator relative to the current Tab. Cannot exceed Tab width.
Value should be a string containing width either in pixels or in percentage.`,name:"TabIndicatorWidth",required:!1,type:{name:"string"}},TabScrollButtonProps:{defaultValue:{value:"{}"},description:"Props applied to the [`TabScrollButton`](/api/tab-scroll-button/) element.",name:"TabScrollButtonProps",required:!1,type:{name:"Partial<TabScrollButtonProps>"}},value:{defaultValue:null,description:"The value of the currently selected `Tab`.\nIf you don't want any selected `Tab`, you can set this prop to `false`.",name:"value",required:!1,type:{name:"any"}},variant:{defaultValue:{value:"'standard'"},description:"Determines additional display behavior of the tabs:\n\n- `scrollable` will invoke scrolling properties and allow for horizontally\nscrolling (or swiping) of the tab bar.\n- `fullWidth` will make the tabs grow to use all the available space,\nwhich should be used for small views, like on mobile.\n- `standard` will render the default state.",name:"variant",required:!1,type:{name:"enum",value:[{value:'"fullWidth"'},{value:'"standard"'},{value:'"scrollable"'}]}},visibleScrollbar:{defaultValue:{value:"false"},description:"If `true`, the scrollbar is visible. It can be useful when displaying\na long vertical list of tabs.",name:"visibleScrollbar",required:!1,type:{name:"boolean"}}}}}catch{}const ln={tags:["autodocs"],component:le,parameters:{references:["Tabs","Tab","TabScrollButton"]},argTypes:{action:{table:{disable:!0}},"aria-label":{table:{disable:!0}},"aria-labelledby":{table:{disable:!0}},centered:{options:[!1,!0],control:"boolean"},children:{table:{disable:!0}},component:{table:{disable:!0}},ScrollButtonComponent:{table:{disable:!0}},scrollButtons:{control:"radio",options:["auto",!0,!1]},slots:{table:{disable:!0}},TabIndicatorProps:{table:{disable:!0}},TabIndicatorSlidingAnimation:{control:"select",options:["expand","slide"]},TabScrollButtonProps:{table:{disable:!0}},value:{table:{disable:!0}}}},Pe={en:["First","Second","Third","Fourth","Fifth","Sixth","Seventh","Eighth","Ninth","Tenth","Eleventh","Twelfth"],ru:["Первый","Второй","Третий","Четвертый","Пятый","Шестой","Седьмой","Восьмой","Девятый","Десятый","Одиннадцатый","Двенадцатый"]},Wt=4,ne={render:function(t,l){const[d,r]=u.useState(0),f=u.useRef([]),m=l.globals.locale||"en",b=(h,g)=>{r(g)};return c.jsx(le,{...t,sx:{[`.${oe.flexContainer}`]:{gap:`${Wt}px`}},value:d,onChange:b,children:(m==="en"?Pe.en:Pe.ru).map((h,g)=>c.jsx(be,{ref:T=>{f.current[g]=T||void 0},endIcon:c.jsx(ke,{size:"24px"}),label:h,startIcon:c.jsx(ke,{size:"24px"})},g))})}};var _e,He,ze;ne.parameters={...ne.parameters,docs:{...(_e=ne.parameters)==null?void 0:_e.docs,source:{originalSource:`{
  render: function Render(args, context) {
    const [value, setValue] = useState(0);
    const tabRefs = useRef<Array<HTMLButtonElement | undefined>>([]);
    const locale = (context.globals.locale || 'en') as 'en' | 'ru';
    const handleChange = (event: SyntheticEvent, newValue: number) => {
      setValue(newValue);
    };
    return <Tabs {...args} sx={{
      [\`.\${tabsClasses.flexContainer}\`]: {
        gap: \`\${gap}px\`
      }
    }} value={value} onChange={handleChange}>
        {(locale === 'en' ? tabsData.en : tabsData.ru).map((label, index) => <Tab key={index} ref={el => {
        tabRefs.current[index] = el || undefined;
      }} endIcon={<IconAt size="24px" />} label={label} startIcon={<IconAt size="24px" />} />)}
      </Tabs>;
  }
}`,...(ze=(He=ne.parameters)==null?void 0:He.docs)==null?void 0:ze.source}}};const an=["Demo"];export{ne as Demo,an as __namedExportsOrder,ln as default};
