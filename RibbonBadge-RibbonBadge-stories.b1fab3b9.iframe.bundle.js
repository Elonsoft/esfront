"use strict";(self.webpackChunk_esfront_react=self.webpackChunk_esfront_react||[]).push([[5293],{"./src/components/ButtonBase/ButtonBase.classes.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{$:()=>getButtonBaseUtilityClass,W:()=>buttonBaseClasses});var _mui_material__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/@mui/utils/generateUtilityClass/generateUtilityClass.js");function getButtonBaseUtilityClass(slot){return(0,_mui_material__WEBPACK_IMPORTED_MODULE_0__.ZP)("ESButtonBase",slot)}const buttonBaseClasses=(0,__webpack_require__("../../node_modules/@mui/utils/generateUtilityClasses/generateUtilityClasses.js").Z)("ESButtonBase",["root","disabled","disableTouchRipple","pressed","wrapper"])},"./src/components/ButtonBase/ButtonBase.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{X:()=>ButtonBase});var react=__webpack_require__("../../node_modules/react/index.js"),clsx_m=__webpack_require__("../../node_modules/clsx/dist/clsx.m.js"),ButtonBase_classes=__webpack_require__("./src/components/ButtonBase/ButtonBase.classes.ts"),composeClasses=__webpack_require__("../../node_modules/@mui/utils/composeClasses/composeClasses.js"),styled=__webpack_require__("../../node_modules/@mui/material/styles/styled.js"),useThemeProps=__webpack_require__("../../node_modules/@mui/material/styles/useThemeProps.js"),useForkRef=__webpack_require__("./src/hooks/useForkRef/useForkRef.ts"),TouchRipple_classes=__webpack_require__("./src/components/TouchRipple/TouchRipple.classes.ts");const EASING_STANDARD="cubic-bezier(0.2, 0, 0, 1)";var State=function(State){return State[State.INACTIVE=0]="INACTIVE",State[State.TOUCH_DELAY=1]="TOUCH_DELAY",State[State.HOLDING=2]="HOLDING",State[State.WAITING_FOR_CLICK=3]="WAITING_FOR_CLICK",State}(State||{});const useTouchRipple=({center,disabled,pressGrowDuration=800,minimumPressDuration=150,...rest})=>{const ref=(0,react.useRef)(null),[pressed,setPressed]=(0,react.useState)(!1),initialSize=(0,react.useRef)(0),rippleSize=(0,react.useRef)(""),rippleScale=(0,react.useRef)(""),hovered=(0,react.useRef)(!1),state=(0,react.useRef)(State.INACTIVE),checkBoundsAfterContextMenu=(0,react.useRef)(!1),shouldReactToKeyboard=(0,react.useRef)(!1),rippleStartEvent=(0,react.useRef)(void 0),growAnimation=(0,react.useRef)(null),isTouch=({pointerType})=>"touch"===pointerType,shouldReactToEvent=event=>{if(disabled||!event.isPrimary)return!1;if(!event.isPrimary)return!1;if(rippleStartEvent.current&&rippleStartEvent.current.pointerId!==event.pointerId)return!1;if("pointerenter"===event.type||"pointerleave"===event.type)return!isTouch(event);const isPrimaryButton=1===event.buttons;return isTouch(event)||isPrimaryButton},getTranslationCoordinates=positionEvent=>{const{height,width}=ref.current.getBoundingClientRect(),endPoint={x:(width-initialSize.current)/2,y:(height-initialSize.current)/2};let startPoint;return startPoint=positionEvent&&!center?(pointerEvent=>{if(!pointerEvent)return{x:0,y:0};const{scrollX,scrollY}=window,{left,top}=ref.current.getBoundingClientRect(),documentX=scrollX+left,documentY=scrollY+top,{pageX,pageY}=pointerEvent;return{x:pageX-documentX,y:pageY-documentY}})(positionEvent):{x:width/2,y:height/2},startPoint={x:startPoint.x-initialSize.current/2,y:startPoint.y-initialSize.current/2},{startPoint,endPoint}},startPressAnimation=positionEvent=>{shouldReactToKeyboard.current=!1,setPressed(!0),growAnimation.current?.cancel(),(()=>{if(!ref.current)return;const{height,width}=ref.current.getBoundingClientRect(),maxDim=Math.max(height,width),softEdgeSize=Math.max(.35*maxDim,75),initialSizeV=Math.floor(.2*maxDim),maxRadius=Math.sqrt(width**2+height**2)+10;initialSize.current=initialSizeV,rippleScale.current=""+(maxRadius+softEdgeSize)/initialSizeV,rippleSize.current=`${initialSize.current}px`})();const{startPoint,endPoint}=getTranslationCoordinates(positionEvent),translateStart=`${startPoint.x}px, ${startPoint.y}px`,translateEnd=`${endPoint.x}px, ${endPoint.y}px`;growAnimation.current=ref.current.animate({top:[0,0],left:[0,0],height:[rippleSize.current,rippleSize.current],width:[rippleSize.current,rippleSize.current],transform:[`translate(${translateStart}) scale(1)`,`translate(${translateEnd}) scale(${rippleScale.current})`]},{pseudoElement:"::after",duration:pressGrowDuration,easing:EASING_STANDARD,fill:"forwards"})},endPressAnimation=async()=>{rippleStartEvent.current=void 0,state.current=State.INACTIVE;const animation=growAnimation.current;let pressAnimationPlayState=1/0;"number"==typeof animation?.currentTime?pressAnimationPlayState=animation.currentTime:animation?.currentTime&&(pressAnimationPlayState=animation.currentTime.to("ms").value),pressAnimationPlayState>=minimumPressDuration?setPressed(!1):(await new Promise((resolve=>{setTimeout(resolve,minimumPressDuration-pressAnimationPlayState)})),growAnimation.current===animation&&setPressed(!1))};return{ref,pressed,bind:{onClick:event=>{rest.onClick?.(event),disabled||(state.current!==State.WAITING_FOR_CLICK?state.current===State.INACTIVE&&shouldReactToKeyboard.current&&(startPressAnimation(),endPressAnimation()):endPressAnimation())},onContextMenu:event=>{rest.onContextMenu?.(event),disabled||(checkBoundsAfterContextMenu.current=!0,endPressAnimation())},onPointerCancel:event=>{shouldReactToEvent(event)&&endPressAnimation()},onPointerUp:event=>{rest.onPointerUp?.(event),shouldReactToEvent(event)&&(state.current!==State.HOLDING?state.current===State.TOUCH_DELAY&&(state.current=State.WAITING_FOR_CLICK,startPressAnimation(rippleStartEvent.current)):state.current=State.WAITING_FOR_CLICK)},onPointerDown:async event=>{if(rest.onPointerDown?.(event),shouldReactToEvent(event)){if(event.persist(),rippleStartEvent.current=event,!isTouch(event))return state.current=State.WAITING_FOR_CLICK,void startPressAnimation(event);checkBoundsAfterContextMenu.current&&!(event=>{const{pageX:x,pageY:y}=event,{top,left,bottom,right}=ref.current.getBoundingClientRect();return x>=left&&x<=right&&y>=top&&y<=bottom})(event)||(checkBoundsAfterContextMenu.current=!1,state.current=State.TOUCH_DELAY,await new Promise((resolve=>{setTimeout(resolve,150)})),state.current===State.TOUCH_DELAY&&(state.current=State.HOLDING,startPressAnimation(event)))}},onPointerLeave:event=>{rest.onPointerLeave?.(event),shouldReactToEvent(event)&&(hovered.current=!1,state.current!==State.INACTIVE&&endPressAnimation())},onKeyDown:event=>{rest.onKeyDown?.(event)," "!==event.key&&"Enter"!==event.key||(shouldReactToKeyboard.current=!0)}}}};var jsx_runtime=__webpack_require__("../../node_modules/react/jsx-runtime.js");const TouchRippleRoot=(0,styled.ZP)("div",{name:"ESTouchRipple",slot:"Root",overridesResolver:(_props,styles)=>styles.root})((({theme})=>({borderRadius:"inherit",inset:0,overflow:"hidden",pointerEvents:"none",position:"absolute",zIndex:0,transition:theme.transitions.create(["background-color"],{duration:theme.transitions.duration.short}),"&::after":{content:'""',opacity:0,position:"absolute",background:"radial-gradient(closest-side, var(--pressed) 99%, transparent 100%)",transformOrigin:"center center",transition:"opacity 375ms linear"}}))),TouchRipple=(0,react.forwardRef)((function TouchRipple(inProps,ref){const{className,sx,...props}=(0,useThemeProps.Z)({props:inProps,name:"ESTouchRipple"}),classes=(ownerState=>{const{classes}=ownerState;return(0,composeClasses.Z)({root:["root"]},TouchRipple_classes.H,classes)})({...props});return(0,jsx_runtime.jsx)(TouchRippleRoot,{ref,className:(0,clsx_m.Z)(className,classes.root),sx})}));try{TouchRipple.displayName="TouchRipple",TouchRipple.__docgenInfo={description:"The TouchRipple.",displayName:"TouchRipple",props:{classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"Partial<TouchRippleClasses>"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},className:{defaultValue:null,description:"Class applied to the root element.",name:"className",required:!1,type:{name:"string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/TouchRipple/TouchRipple.tsx#TouchRipple"]={docgenInfo:TouchRipple.__docgenInfo,name:"TouchRipple",path:"src/components/TouchRipple/TouchRipple.tsx#TouchRipple"})}catch(__react_docgen_typescript_loader_error){}const ButtonBaseRoot=(0,styled.ZP)("button",{name:"ESButtonBase",slot:"Root",overridesResolver:(props,styles)=>{const{ownerState:{disabled,disableTouchRipple,pressed}}=props;return[styles.root,disabled&&styles.disabled,disableTouchRipple&&styles.disableTouchRipple,pressed&&styles.disabled]}})((({theme})=>({"--background":"transparent","--text":theme.vars.palette.monoB[500],"--hovered":theme.vars.palette.monoB.A50,"--pressed":theme.vars.palette.monoB.A150,display:"inline-flex",alignItems:"center",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitTapHighlightColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none",textDecoration:"none",overflow:"hidden","&::-moz-focus-inner":{borderStyle:"none"},backgroundColor:"var(--background)",color:"var(--text)",[`&.${ButtonBase_classes.W.disabled}:not(button)`]:{pointerEvents:"none"},"@media (hover: hover)":{[`&:not(.${ButtonBase_classes.W.disabled}):hover > .${TouchRipple_classes.k.root}`]:{backgroundColor:"var(--hovered)"}},[`&:not(.${ButtonBase_classes.W.disabled}):focus-visible`]:{outline:`2px solid ${theme.vars.palette.monoA[500]}`},[`&.${ButtonBase_classes.W.pressed} > .${TouchRipple_classes.k.root}::after`]:{opacity:1,transitionDuration:"105ms"},[`&.${ButtonBase_classes.W.disableTouchRipple}`]:{[`& > .${TouchRipple_classes.k.root}::after`]:{inset:0,background:"var(--pressed)",transition:theme.transitions.create(["opacity"],{duration:theme.transitions.duration.short})},[`&:active > .${TouchRipple_classes.k.root}::after`]:{opacity:1}},"@media print":{colorAdjust:"exact"}}))),ButtonBaseWrapper=(0,styled.ZP)("div",{name:"ESButtonBase",slot:"Wrapper",overridesResolver:(_props,styles)=>styles.wrapper})((()=>({display:"inline-flex",alignItems:"center",justifyContent:"center",width:"100%",height:"100%",zIndex:1}))),ButtonBase=(0,react.forwardRef)((function ButtonBase(inProps,ref){const{component,children,classes:inClasses,className,sx,disabled,disableTouchRipple,type="button",onClick,onContextMenu,onPointerCancel,onPointerDown,onPointerUp,onPointerLeave,onKeyDown,TouchRippleProps,...props}=(0,useThemeProps.Z)({props:inProps,name:"ESButtonBase"}),buttonRef=(0,react.useRef)(null),handleRef=(0,useForkRef.c)(ref,buttonRef),isNonNativeButton=()=>{const button=buttonRef.current;return!!button&&(component&&"button"!==component&&!("A"===button.tagName&&button.href))},{ref:touchRippleRef,pressed,bind}=useTouchRipple({...TouchRippleProps,disabled:disabled||disableTouchRipple,onClick,onContextMenu,onPointerCancel,onPointerDown,onPointerUp,onPointerLeave,onKeyDown:event=>{event.target===event.currentTarget&&isNonNativeButton()&&" "===event.key&&event.preventDefault(),onKeyDown&&onKeyDown(event),event.target===event.currentTarget&&isNonNativeButton()&&"Enter"===event.key&&!disabled&&(event.preventDefault(),onClick&&onClick(event))}}),classes=(ownerState=>{const{classes,disabled,disableTouchRipple,pressed}=ownerState,slots={root:["root",disabled&&"disabled",disableTouchRipple&&"disableTouchRipple",pressed&&"pressed"],wrapper:["wrapper"]};return(0,composeClasses.Z)(slots,ButtonBase_classes.$,classes)})({classes:inClasses,disabled,disableTouchRipple,pressed});return(0,jsx_runtime.jsxs)(ButtonBaseRoot,{ref:handleRef,as:component,className:(0,clsx_m.Z)(className,classes.root),disabled,sx,type,...props,...bind,children:[(0,jsx_runtime.jsx)(ButtonBaseWrapper,{className:classes.wrapper,children}),(0,jsx_runtime.jsx)(TouchRipple,{ref:touchRippleRef})]})}));try{ButtonBase.displayName="ButtonBase",ButtonBase.__docgenInfo={description:"The Button allows users to take actions, and make choices, with a single tap.",displayName:"ButtonBase",props:{component:{defaultValue:null,description:"The component used for the root node.\nEither a string to use a HTML element or a component.",name:"component",required:!0,type:{name:"ElementType<any, keyof IntrinsicElements>"}},classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"(Partial<ButtonBaseClasses> & Partial<ClassNameMap<never>>)"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},disabled:{defaultValue:null,description:"If true, the component is disabled.",name:"disabled",required:!1,type:{name:"boolean"}},disableTouchRipple:{defaultValue:null,description:"If true, the touch ripple effect is disabled.",name:"disableTouchRipple",required:!1,type:{name:"boolean"}},TouchRippleProps:{defaultValue:null,description:"Props applied to the touch ripple component.",name:"TouchRippleProps",required:!1,type:{name:'Partial<Pick<TouchRippleParams, "center" | "pressGrowDuration" | "minimumPressDuration">>'}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/ButtonBase/ButtonBase.tsx#ButtonBase"]={docgenInfo:ButtonBase.__docgenInfo,name:"ButtonBase",path:"src/components/ButtonBase/ButtonBase.tsx#ButtonBase"})}catch(__react_docgen_typescript_loader_error){}},"./src/components/TouchRipple/TouchRipple.classes.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{H:()=>getTouchRippleUtilityClass,k:()=>touchRippleClasses});var _mui_material__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/@mui/utils/generateUtilityClass/generateUtilityClass.js");function getTouchRippleUtilityClass(slot){return(0,_mui_material__WEBPACK_IMPORTED_MODULE_0__.ZP)("ESTouchRipple",slot)}const touchRippleClasses=(0,__webpack_require__("../../node_modules/@mui/utils/generateUtilityClasses/generateUtilityClasses.js").Z)("ESTouchRipple",["root","center","hovered","pressed"])},"./src/hooks/useForkRef/useForkRef.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c:()=>useForkRef});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/react/index.js");const useForkRef=(...refs)=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>refs.every((ref=>null===ref))?null:instance=>{refs.forEach((ref=>{((ref,value)=>{"function"==typeof ref?ref(value):ref&&(ref.current=value)})(ref,instance)}))}),refs)},"./src/components/RibbonBadge/RibbonBadge.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Demo:()=>Demo,__namedExportsOrder:()=>__namedExportsOrder,default:()=>RibbonBadge_stories});var clsx_m=__webpack_require__("../../node_modules/clsx/dist/clsx.m.js"),generateUtilityClass=__webpack_require__("../../node_modules/@mui/utils/generateUtilityClass/generateUtilityClass.js");function getRibbonBadgeUtilityClass(slot){return(0,generateUtilityClass.ZP)("ESRibbonBadge",slot)}const ribbonBadgeClasses=(0,__webpack_require__("../../node_modules/@mui/utils/generateUtilityClasses/generateUtilityClasses.js").Z)("ESRibbonBadge",["root","colorMonoB500","colorPrimary","colorSecondary","colorSuccess","colorWarning","colorError","colorInfo","orientationLeft","orientationRight","clickable"]);var composeClasses=__webpack_require__("../../node_modules/@mui/utils/composeClasses/composeClasses.js"),useThemeProps=__webpack_require__("../../node_modules/@mui/material/styles/useThemeProps.js"),capitalize=__webpack_require__("../../node_modules/@mui/material/utils/capitalize.js"),styled=__webpack_require__("../../node_modules/@mui/material/styles/styled.js"),ButtonBase=__webpack_require__("./src/components/ButtonBase/ButtonBase.tsx"),TouchRipple_classes=__webpack_require__("./src/components/TouchRipple/TouchRipple.classes.ts"),jsx_runtime=__webpack_require__("../../node_modules/react/jsx-runtime.js");const BadgeRoot=(0,styled.ZP)(ButtonBase.X,{name:"ESBadge",slot:"Root",overridesResolver:(props,styles)=>{const{ownerState:{color,orientation,clickable}}=props;return[styles.root,clickable&&styles.clickable,styles[`colors${(0,capitalize.Z)(color)}`],styles[`orientation${(0,capitalize.Z)(orientation)}`]]}})((({theme})=>({...theme.typography.caption,cursor:"default",display:"flex",justifyContent:"center",alignItems:"center",padding:"2px 6px",boxSizing:"border-box",position:"relative",width:"fit-content",overflow:"visible",pointerEvents:"none","&:after":{content:"''",display:"block",position:"absolute",bottom:"-5px",borderStyle:"solid",borderWidth:"2.5px 4px",width:"8px",height:"5px"},[`&.${ribbonBadgeClasses.root}`]:{[`& .${TouchRipple_classes.k.root}`]:{display:"none"}},[`&.${ribbonBadgeClasses.clickable}`]:{cursor:"pointer",pointerEvents:"auto",[`&.${ribbonBadgeClasses.root}`]:{[`& .${TouchRipple_classes.k.root}`]:{display:"block"}}},[`&.${ribbonBadgeClasses.colorSuccess}`]:{"--background":theme.vars.palette.success[300],"--text":theme.vars.palette.monoB[500],"--hovered":theme.vars.palette.monoA.A50,"--pressed":theme.vars.palette.monoA.A150,"--focused":theme.vars.palette.monoA.A200,"&:after":{borderColor:theme.vars.palette.success[400]}},[`&.${ribbonBadgeClasses.colorMonoB500}`]:{"--background":theme.vars.palette.monoB[500],"--text":theme.vars.palette.monoA[500],"--hovered":theme.vars.palette.monoA.A50,"--focused":theme.vars.palette.monoA.A200,"--pressed":theme.vars.palette.monoA.A150,"&:after":{borderColor:theme.vars.palette.monoB.A800}},[`&.${ribbonBadgeClasses.colorPrimary}`]:{"--background":theme.vars.palette.primary[300],"--text":theme.vars.palette.monoB[500],"--hovered":theme.vars.palette.monoA.A50,"--focused":theme.vars.palette.monoA.A200,"--pressed":theme.vars.palette.monoA.A150,"&:after":{borderColor:theme.vars.palette.primary[400]}},[`&.${ribbonBadgeClasses.colorSecondary}`]:{"--background":theme.vars.palette.secondary[300],"--text":theme.vars.palette.black[500],"--hovered":theme.vars.palette.monoA.A50,"--focused":theme.vars.palette.monoA.A200,"--pressed":theme.vars.palette.monoA.A150,"&:after":{borderColor:theme.vars.palette.secondary[400]}},[`&.${ribbonBadgeClasses.colorWarning}`]:{"--background":theme.vars.palette.warning[300],"--text":theme.vars.palette.monoB[500],"--hovered":theme.vars.palette.monoA.A50,"--focused":theme.vars.palette.monoA.A200,"--pressed":theme.vars.palette.monoA.A150,"&:after":{borderColor:theme.vars.palette.warning[400]}},[`&.${ribbonBadgeClasses.colorError}`]:{"--background":theme.vars.palette.error[300],"--text":theme.vars.palette.monoB[500],"--hovered":theme.vars.palette.monoA.A50,"--focused":theme.vars.palette.monoA.A200,"--pressed":theme.vars.palette.monoA.A150,"&:after":{borderColor:theme.vars.palette.error[400]}},[`&.${ribbonBadgeClasses.colorInfo}`]:{"--background":theme.vars.palette.info[300],"--text":theme.vars.palette.monoB[500],"--hovered":theme.vars.palette.monoA.A50,"--focused":theme.vars.palette.monoA.A200,"--pressed":theme.vars.palette.monoA.A150,"&:after":{borderColor:theme.vars.palette.info[400]}},"&:focus-visible":{outline:`2px solid ${theme.vars.palette.monoA[500]}`,outlineOffset:"-2px","&:after":{borderColor:`${theme.vars.palette.monoA[500]}`}},[`&.${ribbonBadgeClasses.orientationLeft}`]:{borderRadius:"4px 4px 4px 0px",[`&.${ribbonBadgeClasses.root}`]:{[`& .${TouchRipple_classes.k.root}`]:{display:"block",borderRadius:"4px 4px 4px 0px"}},"&:after":{left:0,borderLeftColor:"transparent",borderBottomColor:"transparent"}},[`&.${ribbonBadgeClasses.orientationRight}`]:{borderRadius:"4px 4px 0px 4px",[`&.${ribbonBadgeClasses.root}`]:{[`& .${TouchRipple_classes.k.root}`]:{display:"block",borderRadius:"4px 4px 0px 4px"}},"&:after":{right:0,borderRightColor:"transparent",borderBottomColor:"transparent"}}}))),RibbonBadge=inProps=>{const{className,classes:inClasses,color="success",orientation="left",clickable,...props}=(0,useThemeProps.Z)({props:inProps,name:"ESRibbonBadge"}),component=clickable?ButtonBase.X:"div",classes=(ownerState=>{const{classes,color,orientation,clickable}=ownerState,slots={root:["root",clickable&&"clickable",`color${(0,capitalize.Z)(color)}`,`orientation${(0,capitalize.Z)(orientation)}`]};return(0,composeClasses.Z)(slots,getRibbonBadgeUtilityClass,classes)})({classes:inClasses,color,orientation,clickable});return(0,jsx_runtime.jsx)(BadgeRoot,{className:(0,clsx_m.Z)(classes.root,className),component,...props})};try{RibbonBadge.displayName="RibbonBadge",RibbonBadge.__docgenInfo={description:"",displayName:"RibbonBadge",props:{component:{defaultValue:null,description:"The component used for the root node.\nEither a string to use a HTML element or a component.",name:"component",required:!0,type:{name:"ElementType<any, keyof IntrinsicElements>"}},classes:{defaultValue:null,description:"Override or extend the styles applied to the component.",name:"classes",required:!1,type:{name:"(Partial<RibbonBadgeClasses> & Partial<ClassNameMap<never>>)"}},sx:{defaultValue:null,description:"The system prop that allows defining system overrides as well as additional CSS styles.",name:"sx",required:!1,type:{name:"SxProps<Theme>"}},className:{defaultValue:null,description:"Class applied to the root element.",name:"className",required:!1,type:{name:"string"}},orientation:{defaultValue:{value:"left"},description:"Badge orientation.",name:"orientation",required:!1,type:{name:"enum",value:[{value:'"left"'},{value:'"right"'}]}},color:{defaultValue:{value:"success"},description:"Badge variant.",name:"color",required:!1,type:{name:"enum",value:[{value:'"primary"'},{value:'"secondary"'},{value:'"error"'},{value:'"info"'},{value:'"success"'},{value:'"warning"'},{value:'"monoB500"'}]}},clickable:{defaultValue:null,description:"If `true`, the badge will appear clickable, even if the onClick prop is not defined.\nIf `false`, the badge will not appear clickable, even if onClick prop is defined.",name:"clickable",required:!1,type:{name:"boolean"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/RibbonBadge/RibbonBadge.tsx#RibbonBadge"]={docgenInfo:RibbonBadge.__docgenInfo,name:"RibbonBadge",path:"src/components/RibbonBadge/RibbonBadge.tsx#RibbonBadge"})}catch(__react_docgen_typescript_loader_error){}const RibbonBadge_stories={tags:["autodocs"],component:RibbonBadge,parameters:{references:["RibbonBadge"]},argTypes:{component:{table:{disable:!0}},orientation:{options:["left","right"],control:{type:"select"}},color:{options:["success","warning","error","info","secondary","primary","monoB500"],control:{type:"select"}},clickable:{control:{type:"boolean"}},children:{control:{type:"text"}}},args:{orientation:"left",color:"success",children:"text"}},Demo={render:args=>(0,jsx_runtime.jsx)(RibbonBadge,{...args})},__namedExportsOrder=["Demo"];Demo.parameters={...Demo.parameters,docs:{...Demo.parameters?.docs,source:{originalSource:"{\n  render: args => {\n    return <RibbonBadge {...args} />;\n  }\n}",...Demo.parameters?.docs?.source}}}},"../../node_modules/clsx/dist/clsx.m.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function toVal(mix){var k,y,str="";if("string"==typeof mix||"number"==typeof mix)str+=mix;else if("object"==typeof mix)if(Array.isArray(mix))for(k=0;k<mix.length;k++)mix[k]&&(y=toVal(mix[k]))&&(str&&(str+=" "),str+=y);else for(k in mix)mix[k]&&(str&&(str+=" "),str+=k);return str}function __WEBPACK_DEFAULT_EXPORT__(){for(var tmp,x,i=0,str="";i<arguments.length;)(tmp=arguments[i++])&&(x=toVal(tmp))&&(str&&(str+=" "),str+=x);return str}__webpack_require__.d(__webpack_exports__,{Z:()=>__WEBPACK_DEFAULT_EXPORT__})}}]);